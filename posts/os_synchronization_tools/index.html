<!DOCTYPE html><html lang="ko-KR" mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="동기화 도구들 (Synchronization Tools)" /><meta name="author" content="펭덕" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="공룡책(10판) Chapter 6 요약" /><meta property="og:description" content="공룡책(10판) Chapter 6 요약" /><link rel="canonical" href="https://pengduck.github.io/posts/os_synchronization_tools/" /><meta property="og:url" content="https://pengduck.github.io/posts/os_synchronization_tools/" /><meta property="og:site_name" content="펭덕의 주저리x2" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-11-11T22:55:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="동기화 도구들 (Synchronization Tools)" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@펭덕" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"펭덕"},"dateModified":"2022-11-11T22:55:00+09:00","datePublished":"2022-11-11T22:55:00+09:00","description":"공룡책(10판) Chapter 6 요약","headline":"동기화 도구들 (Synchronization Tools)","mainEntityOfPage":{"@type":"WebPage","@id":"https://pengduck.github.io/posts/os_synchronization_tools/"},"url":"https://pengduck.github.io/posts/os_synchronization_tools/"}</script><title>동기화 도구들 (Synchronization Tools) | 펭덕의 주저리x2</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico?v=1693225662" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico?v=1693225662" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png?v=1693225662"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png?v=1693225662"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png?v=1693225662"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png?v=1693225662"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png?v=1693225662"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png?v=1693225662"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png?v=1693225662"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png?v=1693225662"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png?v=1693225662"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png?v=1693225662"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png?v=1693225662"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png?v=1693225662"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png?v=1693225662"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png?v=1693225662"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png?v=1693225662"><link rel="manifest" href="/assets/img/favicons/manifest.json?v=1693225662"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css?v=1693225662"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js?v=1693225662"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$', '$'], ['\\(', '\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script defer src="/app.js?v=1693225662"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/?v=1693225662" alt="avatar" class="mx-auto"> <img src="/assets/img/favicons/android-icon-144x144.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/?v=1693225662">펭덕의 주저리x2</a></div><div class="site-subtitle font-italic">DevBlog by Pengduck</div></div><ul class="w-100"><li class="nav-item"> <a href="/?v=1693225662" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/?v=1693225662" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/?v=1693225662" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/?v=1693225662" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/?v=1693225662" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/pengduck" aria-label="github" class="order-3" target="_blank" rel="noopener" > <i class="fab fa-github-alt"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['rlaehddn01','naver.com'].join('@')" aria-label="email" class="order-4" > <i class="fas fa-envelope"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/?v=1693225662"> Posts </a> </span> <span>동기화 도구들 (Synchronization Tools)</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>동기화 도구들 (Synchronization Tools)</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> 펭덕 </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Fri, Nov 11, 2022, 10:55 PM +0900" prep="on" > Nov 11, 2022 <i class="unloaded">2022-11-11T22:55:00+09:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5044 words">28 min</span></div></div><div class="post-content"> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/82709090/201459213-aac54b5b-1ae6-4ed8-85d2-867002b3b7db.png" class="preview-img" alt="Preview Image"><p>공룡책(10판) Chapter 6 요약</p><p>여러 프로세스간의 경쟁 문제를 다루는 챕터..!</p><h2 id="배경">배경</h2><ul><li>협력적 프로세스(Cooperating process)<ul><li>시스템 내에서 서로 영향을 주거나 받는 프로세스<li>논리적 주소를 공유 혹은은 데이터를 공유한다.<li>공유 데이터를 동시에 접근하면 데이터의 일관성을 망칠 수 있다.</ul></ul><p>데이터 무결성 확보 - 동시 데이터 접근 시 실행 순서를 보장해줘야 논리적 주소나 공유 데이터가 유지될 수 있다.</p><p>생산자 소비자 문제에서 바라보았을때 버퍼를 공유하는 (shared memory, message queue) 비동기적 동작에서 버퍼 항목의 데이터의 무결성 문제가 대두될 수 있다.</p><p><code class="language-plaintext highlighter-rouge">count++</code>, <code class="language-plaintext highlighter-rouge">count--</code> 을 생각해볼 때,</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>// count++
register1 = count
register1 = register + 1
count - register1

// count--
register2 = count
register2 = register2 -1
count = register2
</pre></table></code></div></div><p>각각은 기계어로 구현될 때 여러 statement가 되는데 이를 병행하게 실행하려면 각 3개의 절이 뒤섞인 채로 순차적 실행될 수 있기에 부정확한 상태에 도달할 수 있다.</p><h3 id="--경쟁-상황-_-race-condition">- 경쟁 상황 _ Race condition</h3><p>동시에 여러 개의 프로세스가 동일한 자료를 접근하여 조작하고, 실행 결과가 접근이 발생한 특정 순서에 의존하여 달라질 수 있는 상황이다.</p><p>이를 해결하기 위해서 협력적 프로세스 간의 <strong>프로세스 동기화</strong>, <strong>조정</strong> 등의 방법이 제시된다.</p><p><br /></p><h2 id="임계구역-문제-_-the-critical-section-problem">임계구역 문제 _ The Critical-Section Problem</h2><p>하나의 프로세스가 임계 구역에 들어가는 경우 일종의 락(lock)을 걸어 나머지 프로세스가 거기에 들어올 수 없도록 하는 것으로, 프로세스들이 데이터를 협력적으로 공유하기 위해서 활동을 동기화할 때 사용하는 프로토콜을 설계하는 것이다.</p><p>동시에 두 프로세스를 같은 구역에서 실행하지 않는다. 각 프로세스는 자신의 임계구역으로 진입할 때 허가를 요청하여야 한다.</p><p>코드는 다음과 같은 구역들로 나뉜다.</p><ul><li>진입 구역 (entry section) : 요청을 구현하는 부분<li>임계 구역 (critical section)<li>퇴출 구역 (exit section) : 임계구역에서 나오는 부분<li>나머지 구역 (remainder section) : 나머지 부분</ul><p>임계구역 문제에 대한 해결안은 다음 세 가지 요구 조건을 충족해야 한다.</p><ol><li>상호 배제 (mutual exclusion) : 프로세스가 자기의 임계구역에서 실행된다면 다른 프로세스들은 임계구역에 진입할 수 없다.<li>진행 (progress) : 임계구역에서 실행중인 프로세스가 없다면 다른 프로세스가 들어갈 수 있어야 한다. - deadlock (임계구역에 아무도 못들어가는 현상) 회피<li>한정된 대기 (bounded waiting) : 프로세스가 임계구역에 들어가기를 무한히 대기해서는 안된다, 즉 진입 허용 횟수에 제한을 두어야 한다. - starvation(새치기로 인하여 어떤 프로세스가 못들어가는 현상) 회피</ol><p>단일 코어에서는 임계구역 문제를 해결할 방법으로 가장 간단한 것은 인터럽트 발생을 막는 것이지만 다중 처리기 환경에서는 이는 불가하다.</p><p>다중 코어 시스템에서의 접근법으로 두가지</p><ul><li>비선점형 커널 : 커널모드에 한번 진입하고 나면 cpu를 계속 쓰게 해주기에 context switch가 없어 경쟁상태가 발생할 여지가 없다. 허나 비효율적이라 성능이 느려 사용하지 않음.<li>선점형 커널 : 프로세스가 언제든 선점될 수 있기 때문에 동기화 문제가 반드시 발생, 다루기 어렵다. 허나 대기 중인 프로세스에 CPU를 양도하기 전에 오랫동안 실행될 위험이 적어서 응답이 민첩할 수 있다.</ul><p><br /></p><h2 id="peterson의-해결안-_-petetsons-solution">Peterson의 해결안 _ Petetson’s Solution</h2><p>while 문으로 무한루프 돌고 있으면 대기 중인 것이다. 여러가지 알고리즘들을 간단히 살펴보자.</p><h4 id="dekker의-알고리즘">Dekker의 알고리즘</h4><p>아래는 Pi 프로세스의 경우이다. <code class="language-plaintext highlighter-rouge">bool flag[2]</code>와 <code class="language-plaintext highlighter-rouge">int turn</code>의 공유 변수를 가진다.</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
   <span class="p">...</span>
   <span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>      <span class="c1">// 임계영역 진입시도</span>
   <span class="k">while</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>    <span class="c1">// Pj가 임계영역에 있는지 확인</span>
      <span class="k">if</span><span class="p">(</span><span class="n">turn</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>   <span class="c1">// 있다면</span>
         <span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>  <span class="c1">// 진입 취소하고</span>
         <span class="k">while</span> <span class="p">(</span><span class="n">turn</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 대기한다</span>
            <span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>   <span class="c1">// 재진입 시도</span>
         <span class="p">}</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="c1">// 임계영역(Critical section)</span>

   <span class="n">turn</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>         <span class="c1">// 진입순서양보</span>
   <span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>  <span class="c1">// 퇴출</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="eisenberg-and-mcguire의-알고리즘">Eisenberg and McGuire의 알고리즘</h4><p>n개의 프로세스에 대한 cs문제의 해결 방안으로 제시되었다.</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="k">do</span> <span class="p">{</span>
   <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">want_in</span><span class="p">;</span>
      <span class="n">j</span> <span class="o">=</span> <span class="n">turn</span><span class="p">;</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="n">I</span><span class="p">)</span> <span class="p">{</span>
         <span class="k">if</span><span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">idle</span><span class="p">)</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">turn</span><span class="p">;</span>
         <span class="k">else</span>
            <span class="n">j</span><span class="o">=</span> <span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">in_cs</span><span class="p">;</span>
      <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
      <span class="k">while</span> <span class="p">((</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">I</span> <span class="o">||</span> <span class="n">flag</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">in_cs</span><span class="p">))</span>
         <span class="n">j</span><span class="o">++</span><span class="p">;</span>
      <span class="k">if</span><span class="p">((</span><span class="n">j</span><span class="o">&gt;=</span><span class="n">n</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">turn</span> <span class="o">==</span> <span class="n">I</span> <span class="o">||</span> <span class="n">flag</span><span class="p">[</span><span class="n">turn</span><span class="p">]</span> <span class="o">==</span> <span class="n">idle</span><span class="p">))</span> <span class="k">break</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="n">turn</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

   <span class="c1">// critical section</span>

   <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">turn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span><span class="p">;</span>
   <span class="k">while</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">idle</span><span class="p">)</span>
      <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span><span class="p">;</span>
   <span class="n">turn</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
   <span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">idle</span><span class="p">;</span>

   <span class="c1">// remainder section</span>
<span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

</pre></table></code></div></div><p>wait 시간이 한없이 길어지지 않는다는데.. 자세히 봐야겠다. turn 변수는 0 또는 1이기에 둘중 하나만이 <code class="language-plaintext highlighter-rouge">while ((j&lt;n)...</code> 문을 통과할 수 있을 것이다.</p><blockquote><p>복잡해보인다…!</p></blockquote><h4 id="bakery-ramport-알고리즘">Bakery Ramport 알고리즘</h4><p>빵집에서 번호표를 나누어주고 차례로 빵을 파는데에서 유래했다고 한다.</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
   <span class="p">...</span>
   <span class="n">choosing</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 번호표 받을 준비</span>

   <span class="n">number</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">number</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">number</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">...,</span> <span class="n">number</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
   <span class="c1">// 다음 번호 할당</span>
   <span class="n">choosing</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// 번호표 받았다</span>
   <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>   <span class="c1">// 모든 프로세스 번호표 비교</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">choosing</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span> <span class="c1">// Pj가 번호표 받을 때까지 대기</span>
         <span class="k">while</span> <span class="p">(</span><span class="n">number</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">number</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">j</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">number</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">));</span>
         <span class="c1">// Pj가 번호표 가지고 있고</span>
         <span class="c1">// Pj 번호표가 Pi번호표보다 작거나 </span>
         <span class="c1">// 또는 번호표가 같을 경우,</span>
         <span class="c1">// j가 i보다 작다면 </span>
         <span class="c1">// Pj의 종료(number[j]=0)까지 대기</span>
   <span class="p">}</span>
   <span class="c1">// CS</span>

   <span class="n">number</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 사용완료</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="피터슨-알고리즘">피터슨 알고리즘</h4><p>본론이다. 복잡한줄 알았는데 이해하는데는 역시 이게 그나마 간단해 보인다. 다만 현대 컴퓨터 구조가 <code class="language-plaintext highlighter-rouge">load</code>와 <code class="language-plaintext highlighter-rouge">store</code> 같은 기본적인 기계어를 수행하는 방식이라 이 알고리즘이 현대 컴퓨터 구조에서 바르게 실행된다 보장할 수는 없다고 한다.</p><p>두 프로세스가 두개의 데이터 항목을 공유한다.</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">turn</span><span class="p">;</span>
<span class="n">boolean</span> <span class="n">flag</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">turn</code>은 다음에 실행될 프로세스를 가리키고 하나가 true면 다른 프로세스가 실행되지 못하도록 제한한다.</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>   <span class="c1">// 임계 구역 진입을 위해 flag 수정</span>
   <span class="n">turn</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>   <span class="c1">// 다음 차례를 j에게 넘김</span>
   <span class="k">while</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">turn</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>  <span class="c1">// Pj의 실행 대기</span>
      <span class="p">;</span>  <span class="c1">// Pj의 플래그가 false이거나 현재 턴이 i인 경우 대기 해제, 임계영역에 진입한다.</span>

      <span class="cm">/* 임계영역 */</span>
   
   <span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>  <span class="c1">// 임계영역 탈출</span>

      <span class="cm">/*  나머지 영역 */</span>
<span class="p">}</span>
</pre></table></code></div></div><p><br /></p><h2 id="동기화를-위한-하드웨어-지원-_-hardware-support-for-synchronization">동기화를 위한 하드웨어 지원 _ Hardware Support for Synchronization</h2><p>위에서 소프트웨어 기반 해결책을 이야기했지만, 역시 문제는 하드웨어 지원이 없으면 어렵다. 기계어 레벨에서의 원자성 보존이 잘 되지 않는다.</p><h3 id="--메모리-장벽-_-memory-barriers">- 메모리 장벽 _ Memory Barriers</h3><p>앞서서 시스템 statement의 순서가 재정렬 될 수 있다는 것을 확인했다. 컴퓨터 아키텍처는 application 에게 메모리 접근 방식을 제공하는데, 이를 메모리 모델이라 한다.</p><p>메모리의 모든 변경 사항을 모든 프로세서로 전파하는 명령어를 제공하여, 다른 프로세서에서 실행중인 스레드에 메모리 변경 사항이 보이게 보장한다. 이런 명령어를 메모리 장벽(Memory Barriers), 메모리 펜스(Memory fences)라고 한다. 메모리 장벽 명령어가 실행될 때, 시스템은 후속 적재, 저장 연산이 수행되기 전에 모든 적재 및 저장이 완료되도록 한다.</p><h3 id="--하드웨어-명령어-_-hardware-instructions">- 하드웨어 명령어 _ Hardware instructions</h3><p>modify, swap을 하드웨어적으로 인터럽트 되지 않는 하나의 단위로 명령어를 제공한다.</p><ul><li><code class="language-plaintext highlighter-rouge">test_and_set()</code> : while문으로 조건을 test and set 을 사용하여 false로 초기화되는 boolean 변수를 선언하여 상호 배제를 이룰 수 있다.</ul><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">boolean</span> <span class="nf">test_and_set</span><span class="p">(</span><span class="n">boolean</span> <span class="o">*</span><span class="n">target</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">boolean</span> <span class="n">rv</span> <span class="o">=</span> <span class="o">*</span><span class="n">target</span><span class="p">;</span>
   <span class="o">*</span><span class="n">target</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

   <span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p>메서드가 원자적으로 실행된다.</p></blockquote><ul><li><code class="language-plaintext highlighter-rouge">compare_and_swap()</code> (CAS) : value를 swap 해준다.integer lock 을 swap, atomic 하게 상호 배제</ul><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">compare_and_swap</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">expected</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_value</span><span class="p">)</span> <span class="p">{</span>
   <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span>
   <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">value</span> <span class="o">==</span> <span class="n">expected</span><span class="p">)</span> <span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">new_value</span><span class="p">;</span>

   <span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="--원자적-변수-_-atomic-variables">- 원자적 변수 _ Atomic Variables</h3><p>원자적 동작이라고 하는 것은 인터럽트를 할 수 없는 오퍼레이션의 단위이다. (cpu 1 clk로 할 수 있도록)</p><p><code class="language-plaintext highlighter-rouge">compare_and_swap()</code>은 상호 배제를 위해 직접 사용되기보다 원자적 변수를 구축하기 위해 사용된다. 정수나 부울 같은 기본 데이터 유형에 대한 원자적 연산을 제공한다. 원자적 갱신을 제공하지만 모든 상황에서 경쟁 조건을 완벽히 해결해주지는 않는다.</p><blockquote><p>유한 버퍼 문제에서 조건이 count값에 따라 달라지는 while 루프에서, <code class="language-plaintext highlighter-rouge">(count &gt; 0)</code> 생산자가 버퍼에 원소를 넣으면 단지 1로 세트되었는데도 두 소비자가 while루프를 빠져나오는 경우가 생긴다.</p></blockquote><p>대개 카운터나 시퀀스 생성기와 같은 공유 데이터 한 에만 제한되어 사용되는 경우가 많다.</p><h2 id="mutex-locks">Mutex Locks</h2><p>csp 해결을 위한 고급 레벨의 소프트웨어 툴</p><ul><li>뮤텍스 락 : 동기화를 위한 가장 간단한 도구 2개 제어<li>세마포어 : n개를 제어할 수 있어서 매우 편리<li>모니터 : 뮤텍스와 세마포어의 단점을 극복 -&gt; Java에서 사용 (wait, notify)<li>Liveness : 프로그레스, 데드락 문제 해결</ul><blockquote><p>Mutex : <strong>mut</strong>ual <strong>ex</strong>clusion 상호 배제</p></blockquote><p>임계 영역을 보호하고 경쟁 상태, 공용 자원 엑세스를 방지한다. lock을 사용한다. cs에 진입하기 위해 lock을 획득하는 과정과 exit할 때 release (반납)하는 과정이 있다.</p><p>락을 획득하고 반환하는 <code class="language-plaintext highlighter-rouge">acquire()</code>, <code class="language-plaintext highlighter-rouge">release()</code> 두개의 함수 제공, available이라는 boolean variable 이용해서 lock을 결정</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">acquire</span><span class="p">()</span> <span class="p">{</span>
   <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">available</span><span class="p">)</span>
      <span class="p">;</span> <span class="cm">/* busy wait */</span>
   <span class="n">avavilable</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">release</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">available</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>이 두 과정도 원자적으로 실행되어야 한다.</p><p>하지만 <code class="language-plaintext highlighter-rouge">바쁜 대기 (Busy waiting)</code> 문제가 여전히 존재; 임계구역 들어가기 전에 <code class="language-plaintext highlighter-rouge">acquire()</code> 반복문의 무한 루프를 도는 현상, cpu 자원을 계속 먹는다. <code class="language-plaintext highlighter-rouge">스핀락(spinlock)</code>은 busy wait를 하는 락 유형이다. CPU 코어가 여러개인 경우 문맥 교환이 일어나지 않기에 해당 시간을 절약할 수 있다.</p><p><br /></p><h2 id="세마포-semaphores">세마포 Semaphores</h2><p>신호장치, 신호기.</p><ul><li>binary semaphore : 0하고 1만 왔다갔다, 뮤텍스 락 하고 같다.<li>Counting semaphore : 무한대로 늘어날 수 있다. 여러개의 인스턴스를 가진 자원</ul><p>함수는 <code class="language-plaintext highlighter-rouge">wait()</code>, <code class="language-plaintext highlighter-rouge">signal()</code> 혹은 <code class="language-plaintext highlighter-rouge">P()</code>, <code class="language-plaintext highlighter-rouge">V()</code></p><p>Proberen(to test) Verhogen(to increment)</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">wait</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">while</span> <span class="p">(</span><span class="n">S</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">;</span> <span class="c1">// busy wait</span>
   <span class="n">S</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">signal</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">S</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>이것도 둘다 atomic 하게 구현되어야 함. 정수를 사용하여 n개의 인스턴스를 가진 자원을 써먹을 수 있다.</p><p>resource가 available한 개수로 초기화를 한다. 리소스를 사용하려면 wait()를 사용 count를 감소, 리소스를 다 썼으면 signal()을 사용 count를 증가</p><blockquote><p>count가 0인 상태에서는 모든 리소스가 사용중이라는 것</p></blockquote><p>이것도 busy waiting 문제가 있다. 이 문제를 해결하려면 wait()를 할 때 while문을 돌지 말고 waiting queue에 들어가면 된다.</p><p><br /></p><h2 id="모니터-_-monitors">모니터 _ Monitors</h2><p>뮤텍스와 세마포어가 편리하지만 <em>타이밍 오류</em>가 자주 발생한다. 특정한 시퀀스를 잘못 쓰면 항상 일어나지도 않고 잡기 어려운 문제가 발생한다. 가령 연산의 순서가 바뀔 경우 상호 배제가 지켜지지 않는 현상이 발생할 수 있는데, 이런 상황이 언제나 재현 가능하지도 않다.</p><p>문제를 낮출 방법. 심플한 동기화 툴을 사용하자. 모니터는 에러가 잘 발생하지 않는 기법이다.</p><h3 id="모니터-사용법-_-usage">모니터 사용법 _ Usage</h3><p>추상화된 데이터 형 <code class="language-plaintext highlighter-rouge">ADT (abstract data type)</code> 은 데이터와 데이터 조작 함수 집합을 하나의 단위로 묶어 보호한다. 즉 상호 배제 자체의 틀을 제공하며, variable을 선언하고 거기에 define된 인스턴스를 호출하도록 한다. 자체적으로 하면 약간 부족해서, conditional variable을 도입한다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">condition</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">;</span>
<span class="n">x</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span> <span class="c1">// 을 호출 하면</span>
<span class="n">x</span><span class="o">.</span><span class="na">signal</span><span class="o">();</span> <span class="c1">// 다른 프로세스가 이것을 호출할때까지 일시중지된다.</span>
<span class="n">y</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
<span class="n">y</span><span class="o">.</span><span class="na">signal</span><span class="o">();</span>
</pre></table></code></div></div><p>각각의 conditional 변수에 호출될 수 있는 연산은 wait()와 signal()이다. wait() 를 호출한 프로세스는 다른 프로세스가 signal()을 호출할 때까지 기다린다.</p><h3 id="java-monitors">Java Monitors</h3><p>자바에서는 monitor-lock 혹은 intrinsic-lock을 제공한다. 기본 단위가 thread이므로 thread synchronization을 구현</p><ul><li>synchronized keyword : 임계영역에 해당하는 코드 블록을 선언할 때 사용하는 자바 키워드</ul><p>해당 코드 블록(임계영역)에는 모니터락을 획득해야 진입 가능하며, 모니터락을 가진 객체 인스턴스를 지정할 수 있다. 메소드에 선언하면 메소드 코드 블록 저체가 임계영역으로 지정된다.</p><ul><li>이 때, 모니터락을 가진 객체 인스턴스는 this 객체 인스턴스임</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kd">synchronized</span> <span class="o">(</span><span class="n">object</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 이 때 object는 모니터락</span>
   <span class="c1">//critical section</span>
<span class="o">}</span> <span class="c1">// 임계영역만 정해주면 나머지 엔트리 섹션 등은 자바가 알아서 해주겠다.</span>

<span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">()</span> <span class="o">{</span>
   <span class="c1">//critical section</span>
<span class="o">}</span> <span class="c1">// 메소드를 호출할 때는 this객체의 모니터락을 획득하고 진입했다가 나올 때 반납하면 된다.</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">wait()</code> <code class="language-plaintext highlighter-rouge">notify()</code> 메소드</p><ul><li>java.lang.Object 클래스에 선언됨 : 모든 자바 객체가 가진 메소드임<li>wait:wait, notify:signal<li>스레드가 어떤 객체의 wait() 메소드를 호출하면 해당 객체의 모니터락을 획득하기 위해 대기 상태로 진입함.<li>스레드가 어떤 객체의 notify() 메소드를 호출하면 해당 객체 모니터에 대기중인 스레드 하나를 깨움.<li>notify() 대힌에 notifyAll() 메소드를 호출하면 해당 객체 모니터에 대기중인 스레드 전부를 깨움 -&gt; 모두가 레디 큐에 들어갔다가 하나만 실행, 나머지는 다시 대기</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SynchExample1</span> <span class="o">{</span>
   <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Counter</span> <span class="o">{</span>
      <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
      <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">increment</span><span class="o">()</span> <span class="o">{</span>
         <span class="n">count</span><span class="o">++;</span>
      <span class="o">}</span>
   <span class="o">}</span>

   <span class="kd">static</span> <span class="kd">class</span> <span class="nc">MyRunnable</span> <span class="kd">implements</span> <span class="nc">Runnable</span> <span class="o">{</span>
      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
         <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="nc">Counter</span><span class="o">.</span><span class="na">increment</span><span class="o">();</span>
      <span class="o">}</span>
   <span class="o">}</span>

   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
      <span class="nc">Thread</span><span class="o">[]</span> <span class="n">threads</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">[</span><span class="mi">5</span><span class="o">];</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">threads</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
         <span class="n">threads</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">MyRunnable</span><span class="o">());</span>
         <span class="n">threads</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">start</span><span class="o">();</span>
      <span class="o">}</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">threads</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
         <span class="n">threads</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">join</span><span class="o">();</span>
      <span class="o">}</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"counter = "</span> <span class="o">+</span> <span class="nc">Counter</span><span class="o">.</span><span class="na">count</span><span class="o">);</span>
   <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>race condition이 발생해 50000근처에도 못간다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SynchExample2</span> <span class="o">{</span>
   <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Counter</span> <span class="o">{</span>
      <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
      <span class="kd">synchronized</span> <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">increment</span><span class="o">()</span> <span class="o">{</span>
         <span class="n">count</span><span class="o">++;</span>
      <span class="o">}</span> <span class="c1">// synchronized 만 선언해도 임계영역이 된다.</span>
   <span class="o">}</span>

   <span class="kd">static</span> <span class="kd">class</span> <span class="nc">MyRunnable</span> <span class="kd">implements</span> <span class="nc">Runnable</span> <span class="o">{</span>
      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
         <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="nc">Counter</span><span class="o">.</span><span class="na">increment</span><span class="o">();</span>
      <span class="o">}</span>
   <span class="o">}</span>

   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
      <span class="nc">Thread</span><span class="o">[]</span> <span class="n">threads</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">[</span><span class="mi">5</span><span class="o">];</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">threads</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
         <span class="n">threads</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">MyRunnable</span><span class="o">());</span>
         <span class="n">threads</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">start</span><span class="o">();</span>
      <span class="o">}</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">threads</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
         <span class="n">threads</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">join</span><span class="o">();</span>
      <span class="o">}</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"counter = "</span> <span class="o">+</span> <span class="nc">Counter</span><span class="o">.</span><span class="na">count</span><span class="o">);</span>
   <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>아주 잘된다. 편하긴 하지만 허나 남발하면 임계영역 구간이 길어지며 동기화되면 멀티스레딩의 장점이 사라진다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>   <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Counter</span> <span class="o">{</span>
      <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Object</span> <span class="n">object</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
      <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
      <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">increment</span><span class="o">()</span> <span class="o">{</span>
         <span class="kd">synchronized</span><span class="o">(</span><span class="n">object</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">count</span><span class="o">++;</span>
         <span class="o">}</span> <span class="c1">// 멍따 object 선언해서 락을 주자.</span>
      <span class="o">}</span>
   <span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SynchExample4</span> <span class="o">{</span>
   <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Counter</span> <span class="o">{</span>
      <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// 공유</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">increment</span><span class="o">()</span> <span class="o">{</span>
         <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Counter</span><span class="o">.</span><span class="na">count</span><span class="o">++;</span>
         <span class="o">}</span> <span class="c1">// 자기 객체 인스턴스의 monitor lock을 획득해서 증가시켜라</span>
      <span class="o">}</span>
   <span class="o">}</span>

   <span class="kd">static</span> <span class="kd">class</span> <span class="nc">MyRunnable</span> <span class="kd">implements</span> <span class="nc">Runnable</span> <span class="o">{</span>
      <span class="nc">Counter</span> <span class="n">counter</span><span class="o">;</span>
      <span class="kd">public</span> <span class="nf">MyRunnable</span><span class="o">(</span><span class="nc">Counter</span> <span class="n">counter</span><span class="o">)</span> <span class="o">{</span>
         <span class="c1">// 생성자</span>
         <span class="k">this</span><span class="o">.</span><span class="na">counter</span> <span class="o">=</span> <span class="n">counter</span><span class="o">;</span>
      <span class="o">}</span>
      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
         <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
            <span class="n">counter</span><span class="o">.</span><span class="na">increment</span><span class="o">();</span>
      <span class="o">}</span>
   <span class="o">}</span>

   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
      <span class="nc">Thread</span><span class="o">[]</span> <span class="n">threads</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">[</span><span class="mi">5</span><span class="o">];</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">threads</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
         <span class="n">threads</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">MyRunnable</span><span class="o">(</span><span class="k">new</span> <span class="nc">Counter</span><span class="o">()));</span> <span class="c1">// 카운터 인스턴스 선언 (5개, static int count를 공유)</span>
         <span class="n">threads</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">start</span><span class="o">();</span>
      <span class="o">}</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">threads</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
         <span class="n">threads</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">join</span><span class="o">();</span>
      <span class="o">}</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"counter = "</span> <span class="o">+</span> <span class="nc">Counter</span><span class="o">.</span><span class="na">count</span><span class="o">);</span>
   <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>또 동기화 문제 발생 : this가 각각의 인스턴스라서 그렇다 (5개) : lock이 달라서, counter가 새로 생성되어서</p><blockquote><p>해결책</p></blockquote><pre><code class="language-Java">   public static void main(String[] args) throws Exception {
      Thread[] threads = new Thread[5];
      Counter counter = new Counter();
      for (int i=0; i&lt;threads.length; i++) {
         threads[i] = new Thread(new MyRunnable(counter)); // 카운터 인스턴스 하나로 다섯개 스레드가 돈다 this (lock)가 하나가 된다.
         threads[i].start();
      }
      for (int i=0; i&lt;threads.length; i++) {
         threads[i].join();
      }
      System.out.println("counter = " + Counter.count);
   }
</code></pre><p><br /></p><h2 id="라이브니스-_-liveness">라이브니스 _ Liveness</h2><p>mutex, semaphore 등은 상호 배제만 보장하지 deadlock과 starvation 문제를 해결해주진 못한다. 라이브니스는 프로세스 실행 수명주기동안 진행을 보장하기 위해 시스템이 충족해야 하는 속성을 뜻한다. 일종의 약속인듯</p><p>라이브니스 실패로 이어질 수 있는 상황은 다음과 같다.</p><ul><li><p>교착 상태 (Deadlock) :두개 이상의 프로세스가 영원히 기다리는 상태로, 대기 중인 프로세스 중 하나에 의해서만 야기될 수 있는 이벤트를 무한정 기다린다.</p><li><p>우선순위 역전 (Priority Inversion) : 우선순위가 높은 프로세스가 낮은 프로세스에게 밀리는 현상 : 커널 데이터는 락에 의해 보호되기 때문에, 낮은 우선순위 프로세스가 자원 사용을 마칠 때 까지 높은 프로시스가 기다리게 된다. 우선순위 상속 프로토콜 (priority-inheritance protocol) 을 구현하여 해결한다.</p></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href="/categories/cs%EC%A7%80%EC%8B%9D/?v=1693225662">CS지식</a>, <a href="/categories/os/?v=1693225662">OS</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/%EA%B3%B5%EB%A3%A1%EC%B1%85/?v=1693225662" class="post-tag no-text-decoration" >공룡책</a> <a href="/tags/os/?v=1693225662" class="post-tag no-text-decoration" >OS</a> <a href="/tags/operating-system/?v=1693225662" class="post-tag no-text-decoration" >Operating System</a> <a href="/tags/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/?v=1693225662" class="post-tag no-text-decoration" >운영체제</a> <a href="/tags/computer/?v=1693225662" class="post-tag no-text-decoration" >Computer</a> <a href="/tags/%EC%BB%B4%ED%93%A8%ED%84%B0/?v=1693225662" class="post-tag no-text-decoration" >컴퓨터</a> <a href="/tags/%EB%8F%99%EA%B8%B0%ED%99%94/?v=1693225662" class="post-tag no-text-decoration" >동기화</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=동기화 도구들 (Synchronization Tools) - 펭덕의 주저리x2&url=https://pengduck.github.io/posts/os_synchronization_tools/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=동기화 도구들 (Synchronization Tools) - 펭덕의 주저리x2&u=https://pengduck.github.io/posts/os_synchronization_tools/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=동기화 도구들 (Synchronization Tools) - 펭덕의 주저리x2&url=https://pengduck.github.io/posts/os_synchronization_tools/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/kafka_failover/?v=1693225662">카프카 클러스터 (Kafka Cluster) - failover</a><li><a href="/posts/os_virtual_memory/?v=1693225662">가상 메모리 (Virtual Memory)</a><li><a href="/posts/os_main_memory/?v=1693225662">메인 메모리 (Main Memory)</a><li><a href="/posts/post_20220119/?v=1693225662">아니 왜 사이트 갱신이 안돼? CSS / JS Cache Busting</a><li><a href="/posts/post_20210422/?v=1693225662">블로그를 오픈했어요</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/os/?v=1693225662">OS</a> <a class="post-tag" href="/tags/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/?v=1693225662">운영체제</a> <a class="post-tag" href="/tags/operating-system/?v=1693225662">Operating System</a> <a class="post-tag" href="/tags/%EA%B3%B5%EB%A3%A1%EC%B1%85/?v=1693225662">공룡책</a> <a class="post-tag" href="/tags/computer/?v=1693225662">Computer</a> <a class="post-tag" href="/tags/%EC%BB%B4%ED%93%A8%ED%84%B0/?v=1693225662">컴퓨터</a> <a class="post-tag" href="/tags/memory/?v=1693225662">Memory</a> <a class="post-tag" href="/tags/%EB%8F%99%EA%B8%B0%ED%99%94/?v=1693225662">동기화</a> <a class="post-tag" href="/tags/%EB%A9%94%EB%AA%A8%EB%A6%AC/?v=1693225662">메모리</a> <a class="post-tag" href="/tags/agile/?v=1693225662">Agile</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/os_synchronization_ex/?v=1693225662"><div class="card-body"> <span class="timeago small" > Dec 25, 2022 <i class="unloaded">2022-12-25T14:55:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>동기화 예제 (Synchronization Examples)</h3><div class="text-muted small"><p> 공룡책(10판) Chapter 7 요약 이전에는 Race condition에 대한 이야기와 해결 도구들을 살펴봤다면, 이번에는 동기화 문제를 직접 살펴보고 적용하는 단원이라고 하는 듯. 무슨 차이지..? 고전적인 동기화 문제들 동기화 문제에 대한 해결책을 제시할 때 전통적으로 세마포를 많이 이용해 왔다. 여기서도 세마포를 사용할 예정. 단 이진 ...</p></div></div></a></div><div class="card"> <a href="/posts/os_intro/?v=1693225662"><div class="card-body"> <span class="timeago small" > Sep 4, 2022 <i class="unloaded">2022-09-04T11:45:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>OS 스터디를 시작하기 전에..</h3><div class="text-muted small"><p> 운영체제가 무엇인지 대략적으로 가지를 뻗어 보자. Computer? 대략 이야기해서 컴퓨터라는 하드웨어를 운영하는 소프트웨어라고 할 수 있다. 컴퓨터란 정보를 처리하는 기계라고 할 수 있지. 정보 여기서 정보라는 것은 클로드 섀넌(Claude Shannon) 이 정의하기를, 정보량 = 사건이 발생한 확률에 마이너스 로그를 붙인 ...</p></div></div></a></div><div class="card"> <a href="/posts/os_overview/?v=1693225662"><div class="card-body"> <span class="timeago small" > Sep 16, 2022 <i class="unloaded">2022-09-16T19:35:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>OS 서론 (Introduction)</h3><div class="text-muted small"><p> 공룡책(10판) Chapter 1 요약 지난번에 이어 전반적으로 맛을 보는 단계이다. 우선은 가볍게 보자. 운영체제가 할 일 _ What Operation Systems do 컴퓨터 시스템은 하드웨어, 소프트웨어 및 데이터로 구성되어 있으며, 운영체제는 컴퓨터 시스템이 동작할 때 소프트웨어 간의 하드웨어 사용을 제어하여, 유용한 작업을 할 수...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/os_cpu_scheduling/?v=1693225662" class="btn btn-outline-primary" prompt="Older"><p>CPU 스케줄링 (CPU Scheduling)</p></a> <a href="/posts/os_synchronization_ex/?v=1693225662" class="btn btn-outline-primary" prompt="Newer"><p>동기화 예제 (Synchronization Examples)</p></a></div><script src="https://utteranc.es/client.js" repo="pengduck/pengduck-comment" issue-term="url" theme="photon-dark" crossorigin="anonymous" async> </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://twitter.com/username">dw.kim</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/os/?v=1693225662">OS</a> <a class="post-tag" href="/tags/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/?v=1693225662">운영체제</a> <a class="post-tag" href="/tags/operating-system/?v=1693225662">Operating System</a> <a class="post-tag" href="/tags/%EA%B3%B5%EB%A3%A1%EC%B1%85/?v=1693225662">공룡책</a> <a class="post-tag" href="/tags/computer/?v=1693225662">Computer</a> <a class="post-tag" href="/tags/%EC%BB%B4%ED%93%A8%ED%84%B0/?v=1693225662">컴퓨터</a> <a class="post-tag" href="/tags/memory/?v=1693225662">Memory</a> <a class="post-tag" href="/tags/%EB%8F%99%EA%B8%B0%ED%99%94/?v=1693225662">동기화</a> <a class="post-tag" href="/tags/%EB%A9%94%EB%AA%A8%EB%A6%AC/?v=1693225662">메모리</a> <a class="post-tag" href="/tags/agile/?v=1693225662">Agile</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { let initTheme = "default"; if ($("html[mode=dark]").length > 0 || ($("html[mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: "/assets/js/data/search.json?v=1693225662", searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://pengduck.github.io{url}?v=1693225662">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
