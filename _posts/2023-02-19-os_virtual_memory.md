---
title: 가상 메모리 (Virtual Memory)
author: 펭덕
date: 2023-02-19 17:30:00 +0900
categories: [CS지식, OS]
tags: [공룡책, OS, Operating System, 운영체제, 메모리, Memory]
math: true
mermaid: true
image:
   src: https://user-images.githubusercontent.com/82709090/219941457-797d35b6-5d2d-4e3c-bc38-03561c859e94.png
---

공룡책(10판) Chapter 10 요약

9장의 *페이징에서의 스와핑* 부분에서 10장의 언급이 있었다. 물리 메모리보다 큰 프로그램을 실행하는 기법 알아보도록 하자

<br>

## 배경 _ Background

이전에는 실행되고 있는 코드가 반드시 물리 메모리에 존재해야 하였고, 필요에 따라 동적 적재(dynamic loading) 방법을 사용하였다. 동적 적재는 전체 프로세스를 메모리에 올리는 제약을 완화하였지만 프로그래머에게는 여전히 부담이다.

메모리에 전체를 올려놓을 필요는 없다,  배열, 리스트, 테이블과 같은 자료구조들이나 거의 실행되지 않는 코드나 기능이 프로그램에 포함되어 있을 수 있기 때문이다. 프로그램의 일부분만 메모리에 올려놓고 실행함으로 다음과 같은 이점을 챙길 수 있다.

1. 프로그램이 물리 메모리 크기에 의해 제약받지 않음
2. 더 많은 프로그램 동시 수행 가능 - 응답 시간(response time, turn around time)은 늘어나지 않고 CPU 이용률(utilization)과 처리율(throughput)이 높아진다.
3. 프로그램을 메모리에 올리고 스왑(swap) 하는데 필요한 I/O 횟수가 줄어들어 프로그램이 빨리 실행된다.

`가상 메모리`는, 어떤 프로세스가 실행될 때 이를 실제 메모리에 올리지 않고 물리 메모리보다 프로세스의 메모리가 더 커도 실행가능하게 해준다. 실제의 물리 메모리 개념과 개발자의 논리 메모리 개념을 분리한 것이다. 사용하지 않는 메모리는 가상 메모리로써 서브 메모리(SSD나 HDD)에 올려둔다.

`가상 주소 공간`은 프로세스가 메모리에 저장되는 논리적인 모습이다. 논리 주소 상에는 연속적이나 실제 물리적으로는 연속적이지 않을 수 있다. 물리 -> 논리 페이지로 사상하는 것은 메모리 관리 장치에 달렸다.

논리 메모리를 물리 메모리로부터 분리해주는 것 말고도 가상 메모리는 페이지 공유(page sharing)을 통해 파일이나 메모리가 둘 이상의 프로세스들에 의해 공유할 수 있게 한다. (공유하는 파일과 메모리를 shared page에 두고 사용)

<br>

## 요구 페이징 _ Demand Paging

실행 프로그램을 보조저장장치에서 메모리로 적재하는 방법에 대해 생각한다. 여기서의 전략은 필요한 페이지 단위 올리는 것이다. 각각의 페이지를 올리는 시점은 필요한 요청, 요구가 있을 때이다. 그래서 `요구 페이징 (demand paging)` 이다.

### 기본 개념 _ Basic Concepts

프로세스가 실행되는 동안 일부 페이지는 메모리에, 일부는 보조저장장치에 있다. 이 둘을 구분하기 위해 하드웨어 지원이 필요하다. 즉 가상 메모리의 요구 페이지와 실행 중 요청되는 페이지를 구분하는 방법이 필요하다. 여기서 이전에 사용되었던 `valid-invalid bit` 개념을 다시 활용하여, 요구 페이징의 유효성 확인을 수행한다.

- valid: 해당 페이지가 메모리에 있다.
- invalid: 해당 페이지가 유효하지 않거나 보조저장장치(secondary storage)에 있다.

여기서 `페이지 폴트(Page Fault)`란 아직 메모리에 로딩 되지 않는 페이지에 액세스를 요청하는 것이다. 이 때 페이지 폴트 트랩을 발생시킨다. 페이지 폴트를 처리하는 과정은 다음과 같다.

![page_fault](https://user-images.githubusercontent.com/82709090/219947050-8cf23c7b-4d50-469a-9d3e-b80db692d1a1.png)

1. 프로세스에 대한 내부 테이블 (internal table) 을 확인하여 메모리 참조(reference)가 유효한 페이지인지 확인
   - 무효한 참조라면 프로세스는 중단된다.
2. 유효한 참조인데 메모리에 올라오지 않았다면 일단 트랩, 보조저장장치로부터 가져와야 한다.
3. 비어 있는 프레임=가용 프레임(free frame)을 찾는다.
4. 보조저장장치에 있는 페이지를 해당 프레임으로 로드해준다. (OS가 free-frame list를 관리)
5. internal table이나 page table을 갱신, 메모리에 해당 페이지가 있다고 표시한다.
6. 트랩에 의해 중단되었던 명령어를 다시 수행한다. 프로세스는 그 페이지에 메모리가 있었던 것처럼 접근 가능하다.

#### 순수 요구 페이징

극단적 경우에는 메모리에 페이지가 없는 상태로 프로세스를 실행할 수 있고, 처음에 메인 메모리에 아무것도 없기 때문에 첫번째 요청은 무조건 페이지 폴트가 발생한다. 프로세스가 사용하는 모든 페이지가 메모리에 올라올 때까지 필요할 때마다 페이지 폴트가 발생하고 모든 페이지가 적재하면 발생하지 않는데 이것을 `순수 요구 페이징(Pure Demand Paging)`이라 한다. 페이지가 필요해지기 전에는 해당 페이지를 메모리에 적재하지 않는 방법이다.

#### 참조 지역성

프로세스가 여러 페이지에 접근하게 되면 동시다발적 페이지 폴트가 발생할 수 있다. 허나 다행히 이것은 드물다고 한다. 모든 프로그램은 `참조 지역성(locality of reference)` 이라는 성질이 있어 프로그램의 어느 한 특정 부분만 집중적으로 참고하여, 이것 덕분에 요구 페이징은 괜찮은 성능을 보여준다.

#### 하드웨어

요구 페이징을 지원하기 위해 필요한 하드웨어는 페이징, 스와핑을 위한 하드웨어와 동일하다.
- 페이지 테이블(page table): 보호 비트들 혹은 유/무효 비트를 통해 특정 항목을 무효로 설정할 수 있어야 한다.
- 보조저장장치(Secondary memory): 페이징 스왑을 위해 스왑 공간(swap space)으로써 활용되어야 한다.

#### 명령어 처리 재시작 (Instruction Restart)

요구 페이징을 위한 필수적인 사항으로 페이지 폴트 오류 처리 후 명령어 처리를 재시작할 수 있어야 한다. 페이지 폴트이 일어나면 실행중인 프로세스를 대기 큐(wait queue)에 보내서, paging in이 완료되면 wait queue에 신호를 줘서 프로세스의 명령어가 재시작하게 한다.

### 가용 프레임 리스트 _ Free Frame List

페이지 폴트가 발생하면 OS는 요청된 페이지를 보조저장장치에서 메인 메모리로 가져와야 하는데, 요청을 충족시키기 위해 가용 프레임 리스트를 관리하고 있다. 시스템이 시작되면 모든 가용 메모리가 가용 프레임 리스트에 넣어지고, 가용 프레임이 요청되면 가용 프레임 리스트의 크기가 줄어든다. 어느 시점에서 리스트는 0 혹은 특정 임계값으로 떨어지며 이후로 다시 채워진다. 

OS는 일반적으로 `zero-fill-on-demand`라는 기법을 활용하여 가용 프레임 리스트를 관리한다. 할당되기 전에 0으로 모두 채워져 이전 내용이 지워진다. 프레임을 다시 할당하기 전에 프레임의 내용을 지워 주어야 한다. (보안 취약점이 될 수 있다.)

### 요구 페이징의 성능 _ Performance of Demand Paging

요구 페이징은 컴퓨터 시스템의 성능에 영향을 줄 수 있고, 이를 알아보기 위해 요구 페이지 메모리에 대한 `실질 접근 시간(effective access time)`을 계산할 수 있다. 페이지 폴트가 없으면 **실질 접근 시간 = 메모리 접근 시간**이다.

> 실질 접근 시간 = (1 - p) * ma + p * 페이지 폴트 시간

페이지 폴트의 확률이 p이고 (0 <= p < 1), 메모리 접근 시간은 ma(ns단위) 이다. 만약 평균 페이지 폴트 처리 시간이 8ms 이고 메모리 접근시간이 200ns라면

> 실질 접근 시간 = (1-p) * 200 + p * 8000000 = 200 + 7999800 * p

페이지 폴트율에 비례하게 된다. 1000번 중 한번 페이지 폴트가 발생하면 실제 접근 시간은 8.2마이크로 초로 요구 페이징 때문에 성능이 40배 느려진다고 할 수 있다. 

<br>

## 쓰기 시 복사 _ Copy-on-Write

요구 페이징을 함으로 프로세스를 빠르게 시작할 수 있다. 그런데 `fork()` 시스템 콜을 통해 프로세스를 생성한다면 첫 요구 페이징도 생략할 수 있다. 앞서서 배운 `fork()`는 부모 프로세스의 페이지를 그대로 자식 프로세스에 복사하여 주소 공간을 구성하였다. 그런데 대부분의 자식은 곧 `exec()` 시스템 콜을 수행하여 덮어씌워버려 복사해온 페이지는 무쓸모가 된다. 그래서 부모의 페이지를 복사하는게 아닌 `쓰기 시 복사(copy-on-write)`를 사용할 수 있다. read할 때에는 굳이 복사하지 않고 부모의 페이지를 함께 사용하다가, write 작업이 이루어 지면 그 때 복사본 페이지를 만들어 자식 프로세스의 주소 공간에 사상시키는 것이다. 

Linux, maxOS, BSD UNIX 등은 `vfork()`라는 시스템 콜을 제공하는데, 이는 쓰기 시 복사를 사용하지 않고 자식이 부모 주소 공간의 페이지를 변경할 수 있다. 이는 자식이 `exec()`를 하는 경우에 사용한다. 복사가 전혀 발생하지 않아 효율적이다.

