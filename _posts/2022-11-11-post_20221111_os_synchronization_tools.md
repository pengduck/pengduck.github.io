---
title: 동기화 도구들 (Synchronization Tools)
author: 펭덕
date: 2022-11-11 22:55:00 +0900
categories: [CS지식, OS]
tags: [공룡책, OS, Operating System, 운영체제, Computer, 컴퓨터, 동기화]
math: true
mermaid: true
image:
   src: https://user-images.githubusercontent.com/82709090/201459213-aac54b5b-1ae6-4ed8-85d2-867002b3b7db.png
---

공룡책(10판) Chapter 6 요약

여러 프로세스간의 경쟁 문제를 다루는 챕터..!

## 배경

- 협력적 프로세스(Cooperating process)
   - 시스템 내에서 서로 영향을 주거나 받는 프로세스
   - 논리적 주소를 공유 혹은은 데이터를 공유한다. 
   - 공유 데이터를 동시에 접근하면 데이터의 일관성을 망칠 수 있다.

데이터 무결성 확보 - 동시 데이터 접근 시 실행 순서를 보장해줘야 논리적 주소나 공유 데이터가 유지될 수 있다. 

생산자 소비자 문제에서 바라보았을때 버퍼를 공유하는 (shared memory, message queue) 비동기적 동작에서 버퍼 항목의 데이터의 무결성 문제가 대두될 수 있다.

`count++`, `count--` 을 생각해볼 때,

```
// count++
register1 = count
register1 = register + 1
count - register1

// count--
register2 = count
register2 = register2 -1
count = register2
```
각각은 기계어로 구현될 때 여러 statement가 되는데 이를 병행하게 실행하려면 각 3개의 절이 뒤섞인 채로 순차적 실행될 수 있기에 부정확한 상태에 도달할 수 있다.

### - 경쟁 상황 _ Race condition 

동시에 여러 개의 프로세스가 동일한 자료를 접근하여 조작하고, 실행 결과가 접근이 발생한 특정 순서에 의존하여 달라질 수 있는 상황이다.

이를 해결하기 위해서 협력적 프로세스 간의 **프로세스 동기화**, **조정** 등의 방법이 제시된다.

<br>

## 임계구역 문제 _ The Critical-Section Problem

하나의 프로세스가 임계 구역에 들어가는 경우 일종의 락(lock)을 걸어 나머지 프로세스가 거기에 들어올 수 없도록 하는 것으로, 프로세스들이 데이터를 협력적으로 공유하기 위해서 활동을 동기화할 때 사용하는 프로토콜을 설계하는 것이다.

동시에 두 프로세스를 같은 구역에서 실행하지 않는다. 각 프로세스는 자신의 임계구역으로 진입할 때 허가를 요청하여야 한다.

코드는 다음과 같은 구역들로 나뉜다.

- 진입 구역 (entry section) : 요청을 구현하는 부분
- 임계 구역 (critical section)
- 퇴출 구역 (exit section) : 임계구역에서 나오는 부분
- 나머지 구역 (remainder section) : 나머지 부분

임계구역 문제에 대한 해결안은 다음 세 가지 요구 조건을 충족해야 한다.

1. 상호 배제 (mutual exclusion) : 프로세스가 자기의 임계구역에서 실행된다면 다른 프로세스들은 임계구역에 진입할 수 없다.
2. 진행 (progress) : 임계구역에서 실행중인 프로세스가 없다면 다른 프로세스가 들어갈 수 있어야 한다. - deadlock (임계구역에 아무도 못들어가는 현상) 회피
3. 한정된 대기 (bounded waiting) : 프로세스가 임계구역에 들어가기를 무한히 대기해서는 안된다, 즉 진입 허용 횟수에 제한을 두어야 한다. - starvation(새치기로 인하여 어떤 프로세스가 못들어가는 현상) 회피


단일 코어에서는 임계구역 문제를 해결할 방법으로 가장 간단한 것은 인터럽트 발생을 막는 것이지만 다중 처리기 환경에서는 이는 불가하다.

다중 코어 시스템에서의 접근법으로 두가지

- 비선점형 커널 : 커널모드에 한번 진입하고 나면 cpu를 계속 쓰게 해주기에 context switch가 없어 경쟁상태가 발생할 여지가 없다. 허나 비효율적이라 성능이 느려 사용하지 않음.
- 선점형 커널 : 프로세스가 언제든 선점될 수 있기 때문에 동기화 문제가 반드시 발생, 다루기 어렵다. 허나 대기 중인 프로세스에 CPU를 양도하기 전에 오랫동안 실행될 위험이 적어서 응답이 민첩할 수 있다. 


