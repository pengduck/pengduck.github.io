---
title: 프로세스 (Process) ~
author: 펭덕
date: 2022-09-23 20:35:00 +0900
categories: [OS, Study]
tags: [OS, Operating System, 운영체제, 프로세스, Process]
math: true
mermaid: true
image:
   src: https://user-images.githubusercontent.com/82709090/192076468-5df294c4-32d1-466b-806f-c6238510b721.png
---

공룡책(10판) Chapter 3 요약 ~3.6

슬슬 본격 돌입이다! 이해해야 할 내용이 많으므로 다소 분할하여 나중에 게시물을 덧붙일 예정이다.

<br>

## 프로세스 개념 _ Process Concept

### - 프로세스란?

모든 CPU 활동들을 어떻게 부를 것인가?
초창기 컴퓨터는 작업(job)을 실행하는 일괄처리 시스템이었고 이는 곧 사용자 프로그램 또는 task를 실행하는 시분할 시스템으로 발전하였는데, 실행된 프로그램이나 메모리 관리 등 프로그램 내부 활동 등등 프로세스라 할 수 있겠다.

> 프로세스 = 실행중인 프로그램

프로세스의 활동 상태는 프로그램 카운터 값과 프로세서 레지스터의 내용으로 나타낸다. 메모리 배치는 섹션으로 나뉘며 이는 다음과 같다.

- 프로세스 메모리 배치 Memory layout

```
+---------------------------------+ 최대 메모리
|    스택 섹션 (stack section)    | 함수를 호출할 때 임시 데이터 저장장소 (매개변수, 복귀 주소, 지역변수)
+ - - - - - - - - - - - - - - - - +
|                 ↓               |
|                                 | 스택, 힙 섹션이 서로의 메모리 영역 확장
|                 ↑               |
+ - - - - - - - - - - - - - - - - +
|     힙 섹션 (heap section)      | 프로그램 실행 중 동적 할당되는 메모리 (ex. C의 malloc, JAVA의 new)
+---------------------------------+
|                                 | (초기화되지 않은 data)
|   데이터 섹션 (data section)    | 전역 변수 (크기 고정)
|                                 | (초기화 data)
+---------------------------------+
|   텍스트 섹션 (text section)    | 명령어, 실행 코드 (크기 고정)
+---------------------------------+ 0
```

간단한 C 프로그램에서의 메모리 배치를 코드로 살펴보면,
```c
#include <stdio.h>
#include <stdlib.h>

int x; // 초기화되지 않은 데이터 : 데이터 섹션
int y=15; // 초기화 데이터 : 데이터 섹션

int main(int argc, char *argv []) {       // 매개변수 : stack 섹션
   int *values;   //지역변수 : stack 섹션
   int i;         // 지역변수 : stack 섹션

   values = (int *) malloc(sizeof(int)*5);   // 힙 섹션

   for (i=0; i<5; i++)
      values[i] = i;
   
   return 0;
}
```


### - 프로세스 상태

프로세스의 상태는 프로세스의 현재 활동에 따라 정의되며, 아래 상태 중 하나를 가진다.

![process_state](https://user-images.githubusercontent.com/82709090/192076503-0c8b2476-565e-45d1-953f-a5207a26b7d1.png)

- `new` : 프로세스가 생성 중 (`fork()`)
- `running` : 명령어들이 실행되고 있음
- `waiting` : 프로세스가 이벤트를 대기 중 (입출력 혹은 시그널 수신 대기)
- `ready` : 프로세스가 프로세서에 할당되기를 대기
- `terminated` : 프로세스의 실행 종료 (`exit()`, `return 0`)

> 참고 : `terminate` vs `halt`의 차이
- ex ) 아래 코드의 경우
```c
while(true) { }
```
> 중지(`halt`)되지 않지만 사용자가 종료(`terminate`)할수 있다.


### - 프로세스 제어 블록 (Process Control Block, PCB)

프로세스는 운영체제에서 PCB에 의해 표현된다. 프로세스 제어 블록은 프로세스에 관련한 정보를 저장하며, 아래 것들을 포함한다.

```
+-----------------------+ 
|     프로세스 상태     |  new, ready running, waiting ...
+-----------------------+ 
|     프로세스 번호     |  PID (Process ID)
+-----------------------+ 
|    프로그램 카운터    |  프로세스가 다음에 실행할 명령어 주소
+-----------------------+ 
|                       |
|      CPU 레지스터     |  누산기, 인덱스, 스택, 범용 레지스터 및 상태 코드 정보
|                       |  (프로세스가 다시 스케줄 될 때 실행 위해 필요)
+-----------------------+ 
|      메모리 제한      |  메모리 관리 정보
+-----------------------+ 
|    오픈 파일 리스트   |  열린 파일 목록
+-----------------------+ 
|                       |
|       그외 등등       |  CPU 사용 시간, 겨오가 시간, 계정 정보, 입출력 장치 목록 ...  
|                       |
+-----------------------+ 
```

### - 스레드 (Threads)

위 프로세스 모델은 단일의 실행 스레드를 실행하는 프로그램이다. 단일 스레드는 프로세스가 한번에 한 가지 일을 실행하도록 허용한다. 현대 운영체제는 프로세스 개념을 확장하여 한 프로세스가 다수의 실행 스레드를 가질 수 있도록 허용 하며, 여러 스레드가 병렬(pararellel) 로 실행 할 수 있다. 이는 4장에서 자세히 알아보고,,

<br>

## 프로세스 스케줄링 _ Process Scheduling

멀티프로그래밍의 목적은 여러 개의 프로세스를 동시에 실행하는 것으로 CPU 이용 효율을 최대화 하는 것이다. 이를 달성하기 위해 `시분할 (Time Sharing)`이 사용되며, 이는 프로세스 사이에서 CPU 코어를 빠르고 빈번하게 스위칭 하여 프로그램 실행 동안 사용자가 상호 작용을 가능하게 한다. CPU 코어는 한번에 하나의 프로세스를 실행할 수 있기 때문에, `프로세스 스케줄러 (Process Scheduler)` 는 여러 프로세스 중 하나의 프로세스를 어떤 CPU 코어에 할당할지 결정한다. 코어보다 많은 프로세스가 있는 경우 초과 프로세스는 스케줄을 대기한다. 메모리에 있는 프로세스 수를 다중 프로그래밍 정도라고 한다.

### - 스케줄링 큐 _ Scheduling Queue

주요 특징은 first in first out, FIFO이다.

![queueing_diagram](https://user-images.githubusercontent.com/82709090/192081524-4d9a3dab-27c9-4c42-8bdb-71c78363cc05.png)

1. 준비 큐 (Ready Queue)
프로세스가 시스템에 들어가면 준비 큐 (Ready Queue) 에 들어가 준비 상태로 CPU 코어에서 실행되기를 기다린다. 이 큐는 일반적으로 연결 리스트로 저장된다. 준비 큐 헤더에는 리스트의 첫 번째 PCB에 대한 포인터가 저장되고 각 PCB에는 준비 큐의 다음 PCB를 가리키는 포인터 필드가 포함된다.

2. 대기 큐 (Wait Queue)
I/O 완료와 같은 특정 이벤트가 발생하기를 기다리는 프로세스는 대기 큐 (Wait Queue)에 삽입된다.

- 프로세스의 실행 상태에서 나타날 수 있는 이벤트
   1. 프로세스는 처음에 준비 큐에 들어가 실행을 위해 선택되거나 디스패치 될 때까지 기다린다.
   2. 프로세스에 CPU 코어가 할댕되고 실행 상태가 되면 여러 이벤트가 발생할 수 있다.
      1. 프로세스가 I/O 요청을 알리고 다음 I/O 대기 큐에 놓인다.
      2. 프로세스는 자식 프로세스를 만들고 자식의 종료를 기다리는 동안 대기 큐에 놓인다.
      3. 인터럽트, 타임 슬라이스가 만료되어 프로세스가 코어에서 제거, 준비 큐로 돌아간다.

2.1, 2.2의 경우에는 대기, 준비 상태에서 준비 큐로 들어간다. 프로세스는 종료 시 까지 이 주기를 계속하며, 종료 시점에 모든 큐에서 지거되고 PCB와 자원이 반환된다.

### - CPU 스케줄링 _ CPU Scheduling

CPU 스케줄러의 역할은 준비 큐에 있는 프로세스 중에서 선택된 하나의 프로세스에 CPU 코어를 할당하는 것이다.

- 스와핑(Swapping) : 메모리에서 디스크로 스왑아웃 (Swap out) -> 디스크에서 메모리로 스왑인 (Swap in) 하여 상태를 복원, 메모리가 초과 사용되어 가용공간을 확보해야 할 때 사용

### - 컨텍스트(문맥) 교환 _ Context Switch

인터럽트가 발생하면 시스템은 인터럽트 처리가 끝난 후에 컨텍스트를 복구할 수 있도록 현재 실행 중인 프로세스와 현재 컨텍스트를 저장한다. 

- 컨텍스트 (Context) : 프로세스의 PCB에 표현되며, CPU 레지스터 값, 프로세스 상태, 메모리 관리 정보 등을 포함한다.

- 컨텍스트 교환 (Context Switch) : CPU 코어를 다른 프로세스로 교환하려면 이전 프로세스의 상태를 보관하고, 새로운 프로세스의 상태를 복구하는 작업

즉 인터럽트가 일어났을 때 프로세스 실행중인 컨텍스트를 저장하고 재개될때 저장된 프로세스를 복구한다.

<br>

## 프로세스에 대한 연산 _ Operation on Processes

### - 프로세스 생성 _ Process Creation

프로세스가 새로운 프로세스를 실행할 수 있다. 이를 통해 부모, 자식 프로세스와 같은 트리 관계가 성립

- 부모, 자식의 두 프로세스를 실행 시키는 방법
   1. 부모자식 병행 실행
   2. 부모는 자식 실행종료까지 대기

- 주소 공간 측면에서 보았을 때 새 프로세스의 두 가지 가능성
   1. 자식은 부모의 복사본 (주소공간을 복제, 부모와 같은 프로그램과 데이터를 가진다)
   2. 자식은 자신의 새 프로그램을 가지고있음 (새 프로그램 로딩)

시스템 콜의 `fork()` 함수를 호출하면 부모 프로세스는 자신과 같은 자식 프로세스를 생성한다. 둘 중 한 프로세스는 exec()를 통해 자신의 메모리 공간을 새로운 프로그램으로 교체한다. 이 과정을 다음 예를 통해 살펴보자.

```c
#include <sys/types.h>
#include <stdio.h>
#include <unistd.h>

int main()
{
   pid = fork(); // 자식 프로세스 생성

   if (pid < 0) { // 오류 발생시
      fprintf(stderr, "Fork Failed");
      return 1;
   }
   else if (pid == 0) { // 자식 프로세스
      execlp("/bin/ls", "ls", NULL); // 자식의 새로운 프로그램 : 주소 공간을 ls 명령어로 채움
   }
   else { // 부모 프로세스
      wait(NULL); // 자식이 완료될때까지 기다린다, 자식의 exit() 호출 후 진행
      printf("Child Complete");
   }

   return 0;
}
```

![fork](https://user-images.githubusercontent.com/82709090/192081509-bce61b8b-a963-4870-ba29-a0a4768e3a83.png)

fork() 함수로 자식 프로세스를 생성하면 자식 프로세스에는 0의 PID 값을 확인할 수 있고, 부모는 자식 프로세스의 PID를 가진다. 자식 프로세스가 끝나면 (`exit()`) 부모 프로세스는 `wait()` 호출로부터 재개하여, `exit()` 시스템 콜을 사용해 끝낼 수 있다.

### - 프로세스 종료 _ Process Termination

프로세스가 문장의 실행을 끝내고 `exit()` 시스템 콜을 이용해 운영체제에 자신의 삭제를 요청하여 종료가 이루어진다. 프로세스는 시스템 콜을 통해 다른 프로세스의 종료를 유발할 수도 있는데, 보통 종료될 프로세스의 부모만이 호출할 수 있다. 위에 설명하였던 대로 부모는 `fork()` 수행 후 자식의 pid를 전달받아 이를 알고 있다.

다음과 같은 경우에 부모는 자식 중 하나의 실행을 종료할 수 있다.
1. 자식이 자신에 할당된 자원을 초과하여 사용할 경우 (부모가 자식 상태 모니터링할 방편이 주어져야 함)
2. 자식에게 할당된 태스크가 더 이상 필요없을 때
3. 부모가 `exit()`를 수행하는데 운영체제가 부모 종료 후 자식 계속 실행을 허용하지 않는 경우

- 연쇄식 종료 (cascading termination) : 부모가 종료 될 경우 거기서 비롯된 자식 프로세스들을 모두 종료시킴, 운영체제가 수행
- 좀비 프로세스 (Zombie process) : 부모 프로세스는 자식의 종료 상태를 얻도록 인자를 전달받고 종료를 기다리는데(`wait()`), 자식 프로세스가 종료되었는데도 부모 프로세스가 `wait()` 호출을 하지 않아 자식이 반환한 정보를 회수 할 수 없는 경우 발생한다.
- 고아 프로세스 (Orphan process) : 부모가 `wait()` 대신 종료해버렸을 경우에 발생, UNIX는 새로운 부모 프로세스로 init을 지정하여 이 문제를 해결한다.

<br>

## 프로세스간 통신 _ Interprocess Communication

운영체제 내에서 실행되는 병행 프로세스들은 독립적, 혹은 협력적으로 실행된다.

- 독립적 (`Independent`) : 프로세스가 다른 프로세스와 데이터를 공유하지 않는다.
- 협력적 (`Cooperating`) : 실행 중에 다른 프로세스들에 영향을 주거나 받는다.

이 때 프로세스간 협력을 하는 이유는 
1. 정보 공유 (Information Sharing) : 여러 응용 프로그램이 동일한 정보에 접근할 수 있는 환경 제공
2. 계산 가속화 (Computation Speedup) : 태스크를 빠르게 실행하기 위해 여러 개의 서브 태스크로 나누어 병렬로 실행
3. 모듈성 (Modularity) : 시스템 기능을 나누어 모듈식 형태로 시스템을 구성

협력적 프로세스는 서로 데이터를 보내거나 받을 수 있는 `프로세스간 통신 (Interprocess Communication, IPC)` 기법이 필요하다. 여기에는 `공유 메모리(Shared Memory)`, `메시지 전달(Message Passing)` 의 두 가지 모델이 있다.

![ipc_model](https://user-images.githubusercontent.com/82709090/193479562-0f5e202b-5c85-4d7c-b049-e3cd23a7d9f3.png)

좌측이 공유 메모리 방식, 우측이 메시지 전달 방식으로 전자는 메모리를 공유하며 후자는 메시지를 저장할 별도의 영역을 둔다. 상세내용은 아래에 후술

<br>

## 공유 메모리 시스템에서의 프로세스 간 통신 _ IPC in Shared-Memory Systems

공유 메모리 시스템에서의 프로세스 통신에서는 공유 메모리 영역을 구축해야 한다. 일반적으로 운영체제는 한 프로세스가 다른 프로세스의 메모리에 접근을 금지시켜야 하지만 공유 메모리는 이 제약 조건을 제거하여 정보를 교환한다.

### - 생산자, 소비자 문제 
생산자 프로세스는 정보를 생산하고 소비자 프로세스는 정보를 소비한다. 여기서 정보를 공유할 메모리가 필요하며, 이때 사용하는 항목이 `버퍼(buffer)`이다.

무한 버퍼 (unbounded buffer) : 버퍼의 크기에 한계가 없으며 소비자는 새로운 항목을 기다릴 수 있지만 생산자는 항상 새로운 항목을 생산할 수 있다.
유한 버퍼 (bounded buffer) : 버퍼의 크기가 고정되어 있으며, 버퍼가 비어 있으면 소비자는 대기하고 모든 버퍼가 채워지면 생산자가 대기한다.

아래는 유한 버퍼의 예로 다음 변수들은 생산자, 소비자 프로세스가 공유하는 메모리 영역에 존재한다.
```c
#define BUFFER_SIZE 10

typedef struct {
   ...
} item;

item buffer [BUFFER_SIZE];
int in = 0;
int out = 0;
```
공유 버퍼는 두 개의 논리 포인터 `in`과 `out`을 갖는 원형 배열로 구현된다. `in`은 버퍼 내에서 다음 비어 있는 위치, `out`은 버퍼 내에서 첫번째로 채워져 있는 위치를 가리킨다. `in == out`일 때 버퍼는 비어 있고 `((in + 1) % BUFFER_SIZE) == out` 일 때 버퍼는 가득 차 있다.

- 생산자

```c
item next_produced; // 다음 번 생산되는 item

while (true) {
   /* produce an item in next_produced */

   while (((in + 1) % BUFFER_SIZE) == out)
      ; /* do nothing */
   
   buffer[in] = next_produced;
   in = (in + 1) % BUFFER_SIZE;
}
```
- 소비자

```c
item next_consumed; // 다음 번 소비되는 item

while (true) {
   while (in == out)
      ; /* do nothing */
   
   next_consumed = buffer[out];
   out = (out + 1) % BUFFER_SIZE;

   /* consume an item in next_produced */
}
```
이 방법은 최대 `BUFFER_SIZE - 1` 까지 수용할 수 있다. 여기서 `in == out`은 비어 있는 버퍼를 나타내는데, BUFFER_SIZE 까지 모두 수용한다면 비어 있거나 꽉 찬 버퍼 둘 다 나타낼 수 있다. 따라서 빈 버퍼와 꽉찬 버퍼, 둘 중 하나의 상태만을 나타낼 수 있는 조건 혹은 추가 플래그를 제공할 필요가 있다. 

또한 여기서 고려하지 못한 것은 생산자, 소비자가 병행하게 공유 버퍼를 접근할 때의 문제이다. 두 프로세스가 같은 버퍼 주소에 접근할 경우? 라던가... 이런 경우에는 메모리 동시 접근을 막기 위해 그 영역을 어플리케이션 프로그래머가 정의해주어야한다.

<br>

## 메시지 전달 시스템에서의 프로세스 간 통신 _ IPC in Message-Passing Systems

메시지 전달 방식은 동일한 주소 공간을 공유하지 않고도 프로세스들이 통신하고 동기화할 수 있는 기법을 제공한다. 네트워크로 연결된 다른 컴퓨터들에 존재할 수 있는 분산 환경에서 특히 유용하다. 메시지 전달 시스템은 최소한 두 가지 연산을 제공한다.

1. send(message)
2. receive(message)

프로세스 P와 Q가 통신을 하고자 할 떄, 이들 사이에 통신 연결 (Communication Link)이 설정되어야 한다. 하나의 링크와 위 연산을 구현하는 방법은 다음과 같다.

- 직접(direct) 또는 간접(indirect) 통신
- 동기식(synchronous) 또는 비동기식(asynchronous) 통신
- 자동(automatic) 또는 명시적(explicit) 버퍼링

### - 명명 _ Naming

프로세스들이 통신할 때 서로를 명명할 방법이 필요하다. 직, 간접 통신을 사용한다.

- 직접(direct) 통신 : 각 프로세스는 통신의 수신자, 송신자의 이름을 명시한다.
   - 대칭성 : 송, 수신자가 모두 서로의 이름을 제시한다.
   - 비대칭 : 송신자만 수신자 이름을 지명한다. 

이 방법은 지정하여야 하기 떄문에 모듈성을 제한한다. 이른바 하드코딩(hard-coding) 기법이다.

- 간접(indirect) 통신 : 메일박스(mailbox) 또는 포트(port)로 송수신된다.
   - 메일박스 : 메시지를 받거나, 혹은 보낼 저장소. 프로세스에 예속되지 않고 생성 -> 송수신 -> 삭제 과정을 거친다. OS는 해당 과정의 방법을 제공
   - 각 메일박스마다 복수의 수신자를 만들 수 있다.

### - 동기화 _ Synchronization

send, receive 호출에 의해 프로세스간 통신이 발생할 때 메시지 전달은 blocking, nonblocking 방식으로 전달된다.

- 동기식(synchronous) 송, 수신 : 성공 보장
   - Blocking send : 보내는 프로세스는 받는 프로세스 또는 메일박스에 수신될 때까지 대기한다.
   - Blocking receive : 메시지를 다 받을 때까지 받는 프로세스가 대기.
- 비동기식(asynchronous) 송, 수신 : 성공하든 말든 일단 보내보자.
   - Non-Blocking send : 보내는 프로세스는 메시지를 보내고 작업을 재개한다.
   - Non-Blocking receive : 보내는 프로세스가 메시지 또는 null을 수신한다. 받는 프로세스는 계속 작업.


### - 버퍼링 _ Buffering

통신하는 프로세스들에 의해 교환되는 메시지는 큐에 들어 있다. 큐를 구현하는 방식은 다음 세 가지가 있다.

- 무용량 (zero capicity) : 큐의 길이가 0이라 대기하는 메시지가 없고 송신자는 수신자가 수신할때까지 대기한다.
- 유한 용량 (bounded capacity) : 새로운 메시지 전송 시 큐가 꽉 차지 않았다면 메시지는 큐에 쌓이고 송신자는 작업 실행을 계속한다. 꽉 찼다면, 큐가 빌 때까지 대기한다.
- 무한 용량 (unbounded capacity) : 큐는 무한한 사이즈를 가지기 때문에 송신자는 대기하지 않는다. 


<br>




