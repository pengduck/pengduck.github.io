---
title: 프로세스 (Process) _1
author: 펭덕
date: 2022-09-23 20:35:00 +0900
categories: [OS, Study]
tags: [OS, Operating System, 운영체제, 프로세스, Process]
math: true
mermaid: true
image:
   src: https://user-images.githubusercontent.com/82709090/192076468-5df294c4-32d1-466b-806f-c6238510b721.png
---

공룡책(10판) Chapter 3 요약 ~3.3

슬슬 본격 돌입이다! 이해해야 할 내용이 많으므로 다소 분할하여 나중에 게시물을 덧붙일 예정이다.

<br>

## 프로세스 개념 _ Process Concept

### - 프로세스란?

모든 CPU 활동들을 어떻게 부를 것인가?
초창기 컴퓨터는 작업(job)을 실행하는 일괄처리 시스템이었고 이는 곧 사용자 프로그램 또는 task를 실행하는 시분할 시스템으로 발전하였는데,

실행된 프로그램이나 메모리 관리 등 프로그램 내부 활동 등등 프로세스라 할 수 있겠다.

> 프로세스 = 실행중인 프로그램

프로세스의 활동 상태는 프로그램 카운터 값과 프로세서 레지스터의 내용으로 나타낸다. 메모리 배치는 섹션으로 나뉘며 이는 다음과 같다.

- 프로세스 메모리 배치 Memory layout

```
+---------------------------------+ 최대 메모리
|    스택 섹션 (stack section)    | 함수를 호출할 때 임시 데이터 저장장소 (매개변수, 복귀 주소, 지역변수)
+ - - - - - - - - - - - - - - - - +
|                 ↓               |
|                                 | 스택, 힙 섹션이 서로의 메모리 영역 확장
|                 ↑               |
+ - - - - - - - - - - - - - - - - +
|     힙 섹션 (heap section)      | 프로그램 실행 중 동적 할당되는 메모리 (ex. C의 malloc, JAVA의 new)
+---------------------------------+
|                                 | (초기화되지 않은 data)
|   데이터 섹션 (data section)    | 전역 변수 (크기 고정)
|                                 | (초기화 data)
+---------------------------------+
|   텍스트 섹션 (text section)    | 명령어, 실행 코드 (크기 고정)
+---------------------------------+ 0
```

간단한 C 프로그램에서의 메모리 배치를 코드로 살펴보면,
```c
#include <stdio.h>
#include <stdlib.h>

int x; // 초기화되지 않은 데이터 : 데이터 섹션
int y=15; // 초기화 데이터 : 데이터 섹션

int main(int argc, char *argv []) {       // 매개변수 : stack 섹션
   int *values;   //지역변수 : stack 섹션
   int i;         // 지역변수 : stack 섹션

   values = (int *) malloc(sizeof(int)*5);   // 힙 섹션

   for (i=0; i<5; i++)
      values[i] = i;
   
   return 0;
}
```


### - 프로세스 상태

프로세스의 상태는 프로세스의 현재 활동에 따라 정의되며, 아래 상태 중 하나를 가진다.

![process_state](https://user-images.githubusercontent.com/82709090/192076503-0c8b2476-565e-45d1-953f-a5207a26b7d1.png)

- `new` : 프로세스가 생성 중 (`fork()`)
- `running` : 명령어들이 실행되고 있음
- `waiting` : 프로세스가 이벤트를 대기 중 (입출력 혹은 시그널 수신 대기)
- `ready` : 프로세스가 프로세서에 할당되기를 대기
- `terminated` : 프로세스의 실행 종료 (`exit()`, `return 0`)

> 참고 : `terminate` vs `halt`의 차이
- ex ) 아래 코드의 경우
```c
while(true) { }
```
> 중지(`halt`)되지 않지만 사용자가 종료(`terminate`)할수 있다.


### - 프로세스 제어 블록 (Process Control Block, PCB)

프로세스는 운영체제에서 PCB에 의해 표현된다. 프로세스 제어 블록은 프로세스에 관련한 정보를 저장하며, 아래 것들을 포함한다.

```
+-----------------------+ 
|     프로세스 상태     |  new, ready running, waiting ...
+-----------------------+ 
|     프로세스 번호     |  PID (Process ID)
+-----------------------+ 
|    프로그램 카운터    |  프로세스가 다음에 실행할 명령어 주소
+-----------------------+ 
|                       |
|      CPU 레지스터     |  누산기, 인덱스, 스택, 범용 레지스터 및 상태 코드 정보
|                       |  (프로세스가 다시 스케줄 될 때 실행 위해 필요)
+-----------------------+ 
|      메모리 제한      |  메모리 관리 정보
+-----------------------+ 
|    오픈 파일 리스트   |  열린 파일 목록
+-----------------------+ 
|                       |
|       그외 등등       |  CPU 사용 시간, 겨오가 시간, 계정 정보, 입출력 장치 목록 ...  
|                       |
+-----------------------+ 
```

### - 스레드 (Threads)

위 프로세스 모델은 단일의 실행 스레드를 실행하는 프로그램이다. 단일 스레드는 프로세스가 한번에 한 가지 일을 실행하도록 허용한다. 현대 운영체제는 프로세스 개념을 확장하여 한 프로세스가 다수의 실행 스레드를 가질 수 있도록 허용 하며, 여러 스레드가 병렬(pararellel) 로 실행 할 수 있다. 이는 4장에서 자세히 알아보고,,

<br>

## 프로세스 스케줄링 _ Process Scheduling

멀티프로그래밍의 목적은 여러 개의 프로세스를 동시에 실행하는 것으로 CPU 이용 효율을 최대화 하는 것이다. 이를 달성하기 위해 `시분할 (Time Sharing)`이 사용되며, 이는 프로세스 사이에서 CPU 코어를 빠르고 빈번하게 스위칭 하여 프로그램 실행 동안 사용자가 상호 작용을 가능하게 한다. CPU 코어는 한번에 하나의 프로세스를 실행할 수 있기 때문에, `프로세스 스케줄러 (Process Scheduler)` 는 여러 프로세스 중 하나의 프로세스를 어떤 CPU 코어에 할당할지 결정한다. 코어보다 많은 프로세스가 있는 경우 초과 프로세스는 스케줄을 대기한다. 메모리에 있는 프로세스 수를 다중 프로그래밍 정도라고 한다.

### - 스케줄링 큐 _ Scheduling Queue

주요 특징은 first in first out, FIFO이다.

![queueing_diagram](https://user-images.githubusercontent.com/82709090/192081524-4d9a3dab-27c9-4c42-8bdb-71c78363cc05.png)

1. 준비 큐 (Ready Queue)
프로세스가 시스템에 들어가면 준비 큐 (Ready Queue) 에 들어가 준비 상태로 CPU 코어에서 실행되기를 기다린다. 이 큐는 일반적으로 연결 리스트로 저장된다. 준비 큐 헤더에는 리스트의 첫 번째 PCB에 대한 포인터가 저장되고 각 PCB에는 준비 큐의 다음 PCB를 가리키는 포인터 필드가 포함된다.

2. 대기 큐 (Wait Queue)
I/O 완료와 같은 특정 이벤트가 발생하기를 기다리는 프로세스는 대기 큐 (Wait Queue)에 삽입된다.

- 프로세스의 실행 상태에서 나타날 수 있는 이벤트
   1. 프로세스는 처음에 준비 큐에 들어가 실행을 위해 선택되거나 디스패치 될 때까지 기다린다.
   2. 프로세스에 CPU 코어가 할댕되고 실행 상태가 되면 여러 이벤트가 발생할 수 있다.
      1. 프로세스가 I/O 요청을 알리고 다음 I/O 대기 큐에 놓인다.
      2. 프로세스는 자식 프로세스를 만들고 자식의 종료를 기다리는 동안 대기 큐에 놓인다.
      3. 인터럽트, 타임 슬라이스가 만료되어 프로세스가 코어에서 제거, 준비 큐로 돌아간다.

2.1, 2.2의 경우에는 대기, 준비 상태에서 준비 큐로 들어간다. 프로세스는 종료 시 까지 이 주기를 계속하며, 종료 시점에 모든 큐에서 지거되고 PCB와 자원이 반환된다.

### - CPU 스케줄링 _ CPU Scheduling

CPU 스케줄러의 역할은 준비 큐에 있는 프로세스 중에서 선택된 하나의 프로세스에 CPU 코어를 할당하는 것이다.

- 스와핑(Swapping) : 메모리에서 디스크로 스왑아웃 (Swap out) -> 디스크에서 메모리로 스왑인 (Swap in) 하여 상태를 복원, 메모리가 초과 사용되어 가용공간을 확보해야 할 때 사용

### - 컨텍스트(문맥) 교환 _ Context Switch

인터럽트가 발생하면 시스템은 인터럽트 처리가 끝난 후에 컨텍스트를 복구할 수 있도록 현재 실행 중인 프로세스와 현재 컨텍스트를 저장한다. 

- 컨텍스트 (Context) : 프로세스의 PCB에 표현되며, CPU 레지스터 값, 프로세스 상태, 메모리 관리 정보 등을 포함한다.

- 컨텍스트 교환 (Context Switch) : CPU 코어를 다른 프로세스로 교환하려면 이전 프로세스의 상태를 보관하고, 새로운 프로세스의 상태를 복구하는 작업

즉 인터럽트가 일어났을 때 프로세스 실행중인 컨텍스트를 저장하고 재개될때 저장된 프로세스를 복구한다.

<br>

## 프로세스에 대한 연산 _ Operation on Processes

### - 프로세스 생성 _ Process Creation

프로세스가 새로운 프로세스를 실행할 수 있다. 이를 통해 부모, 자식 프로세스와 같은 트리 관계가 성립

- 부모, 자식의 두 프로세스를 실행 시키는 방법
   1. 부모자식 병행 실행
   2. 부모는 자식 실행종료까지 대기

- 주소 공간 측면에서 보았을 때 새 프로세스의 두 가지 가능성
   1. 자식은 부모의 복사본 (주소공간을 복제, 부모와 같은 프로그램과 데이터를 가진다)
   2. 자식은 자신의 새 프로그램을 가지고있음 (새 프로그램 로딩)

시스템 콜의 `fork()` 함수를 호출하면 부모 프로세스는 자신과 같은 자식 프로세스를 생성한다. 둘 중 한 프로세스는 exec()를 통해 자신의 메모리 공간을 새로운 프로그램으로 교체한다. 이 과정을 다음 예를 통해 살펴보자.

```c
#include <sys/types.h>
#include <stdio.h>
#include <unistd.h>

int main()
{
   pid = fork(); // 자식 프로세스 생성

   if (pid < 0) { // 오류 발생시
      fprintf(stderr, "Fork Failed");
      return 1;
   }
   else if (pid == 0) { // 자식 프로세스
      execlp("/bin/ls", "ls", NULL); // 자식의 새로운 프로그램 : 주소 공간을 ls 명령어로 채움
   }
   else { // 부모 프로세스
      wait(NULL); // 자식이 완료될때까지 기다린다, 자식의 exit() 호출 후 진행
      printf("Child Complete");
   }

   return 0;
}
```

![fork](https://user-images.githubusercontent.com/82709090/192081509-bce61b8b-a963-4870-ba29-a0a4768e3a83.png)

fork() 함수로 자식 프로세스를 생성하면 자식 프로세스에는 0의 PID 값을 확인할 수 있고, 부모는 자식 프로세스의 PID를 가진다. 자식 프로세스가 끝나면 (`exit()`) 부모 프로세스는 `wait()` 호출로부터 재개하여, `exit()` 시스템 콜을 사용해 끝낼 수 있다.

### - 프로세스 종료 _ Process Termination

프로세스가 문장의 실행을 끝내고 `exit()` 시스템 콜을 이용해 운영체제에 자신의 삭제를 요청하여 종료가 이루어진다. 프로세스는 시스템 콜을 통해 다른 프로세스의 종료를 유발할 수도 있는데, 보통 종료될 프로세스의 부모만이 호출할 수 있다. 위에 설명하였던 대로 부모는 `fork()` 수행 후 자식의 pid를 전달받아 이를 알고 있다.

다음과 같은 경우에 부모는 자식 중 하나의 실행을 종료할 수 있다.
1. 자식이 자신에 할당된 자원을 초과하여 사용할 경우 (부모가 자식 상태 모니터링할 방편이 주어져야 함)
2. 자식에게 할당된 태스크가 더 이상 필요없을 때
3. 부모가 `exit()`를 수행하는데 운영체제가 부모 종료 후 자식 계속 실행을 허용하지 않는 경우

- 연쇄식 종료 (cascading termination) : 부모가 종료 될 경우 거기서 비롯된 자식 프로세스들을 모두 종료시킴, 운영체제가 수행
- 좀비 프로세스 (Zombie process) : 부모 프로세스는 자식의 종료 상태를 얻도록 인자를 전달받고 종료를 기다리는데(`wait()`), 자식 프로세스가 종료되었는데도 부모 프로세스가 `wait()` 호출을 하지 않아 자식이 반환한 정보를 회수 할 수 없는 경우 발생한다.
- 고아 프로세스 (Orphan process) : 부모가 `wait()` 대신 종료해버렸을 경우에 발생, UNIX는 새로운 부모 프로세스로 init을 지정하여 이 문제를 해결한다.


 <br>

 다음은 프로세스 챕터의 후반부, 프로세스간 통신부터..!




