---
title: CPU 스케줄링 (CPU Scheduling)
author: 펭덕
date: 2022-10-26 20:55:00 +0900
categories: [CS지식, OS]
tags: [공룡책, OS, Operating System, 운영체제, Computer, 컴퓨터, CPU, 스케줄링, Scheduling]
math: true
mermaid: true
image:
   src: https://user-images.githubusercontent.com/82709090/198814668-5d71af24-fdf8-4999-9043-ccc9c1de7bc3.png
---

공룡책(10판) Chapter 5 요약

용어들이 넘 많이 나오고 복잡해지고 있어!

## 기본 개념 _ Basic Concepts

멀티프로그래밍의 목적은 곧 CPU 이용률을 최대화 하는 것이다. 하나의 프로세스는 I/O 요청이 완료되기를 기다리며 놀 수 있는데, 이런 대기 시간은 낭비이기에 어떻게든 굴려먹어야 한다. 중요한 컴퓨터 자원인 CPU 자원을 프로세스에 할당, 대기, 양도 등 과정에서 CPU 스케줄링은 운영체제 설계의 핵심이라고 할 수 있다.

### CPU-I/O 버스트 사이클 _ CPU-I/O Burst Cycle

프로세스는 CPU 실행과 I/O 대기의 사이클로 구성된다. CPU 버스트 부터 시작되어 왔다갔다 한다. 그러다 마지막 CPU 버스트는 또 다른 I/O 버스트가 뒤따르고 실행 종료 시스템 요청과 함께 끝난다. 여기서 **CPU 버스트**란 CPU 명령을 실행하는 것, **I/O 버스트**는 I/O를 요청하고 기다리는 것이다.

CPU 버스트가 많은 프로세스를 *CPU 바운드 프로세스* (계산 위주로 하는 프로세스), I/O 버스트가 많으면 *I/O 바운드 프로세스* (사용자 대화형 프로세스) 라고 한다.

### CPU 스케줄러 _ CPU Scheduler

스케줄러는 ready 상태에 있는 프로세스들 중에서 CPU를 할당(allocate) 해줄수 있는 것을 선택한다.

ready 큐는

- Linked list 큐, Binary tree
- FIFO 큐 (선입선출 큐)
- Priority 큐 (우선순위 큐)

로 구현할 수 있다. 큐의 레코드는 일반적으로 PCB이다. 

스케줄링에서는 우선순위를 부여할 방법이 가장 핵심이 될 것임.

### 선점 및 비선점 스케줄링 _ Preemptive and Nonpreemptive Scheduling

스케줄링은 다음 네 가지 상황에서 발생한다.

1. 프로세스가 실행(running) 상테에서 대기(waiting) 상태로 전환될 때; I/O 요청, 자식을 기다리는 wait() 호출
2. 프로세스가 실행(running) 상태에서 준비(ready) 상태로 전환될 때; 인터럽트 발생
3. 프로세스가 대기(waiting) 상태에서 준비(ready) 상태로 전환될 때; I/O의 종료
4. 프로세스가 종료(terminate) 될 때

1, 4 에서만 스케줄링이 발생하면 비선점형 스케줄링이다.

선점에 있어서 신경써야 할 것들은 다음이 있다.
- 선점 스케줄링에서 다수의 프로세스에 의해 데이터가 공유 될 때 데이터 일관성 문제
- 공유 커널 데이터 구조의 엑세스의 경쟁 조건 방지를 위한 락이 필요
- 인터럽트에 의해서 영향을 받는 부분에 대한 동시 사용 제한 (인터럽트 불능화)

### 디스패처 _ Dispatcher


CPU 코어에 CPU 스케줄러가 선택한 프로세스 컨트롤을 넘겨주는 모듈이다.

- 디스패처가 할 일
   - 컨텍스트를 프로세스에서 다른 프로세스로 넘겨주기
   - 유저 모드로 전환
   - 새로운 프로세스의 적당한 위치로 이동(jump)하여 resume

스케줄러와 디스패처의 역할의 다름에 주목하고, 실제 스위치는 디스패처가 하며, 디스패처는 모든 프로세스의 컨텍스트 스위칭 시 호출되기에 빨라야한다. 프로세스를 정지하고 다른 프로세스의 수행을 시작할때까지 걸리는 시간을 디스패치 지연(dispatch latency) 라고 한다.


```
+-----------------------+ 
|        P0 실행        |
+-----------------------+   ---
            |                |
+-----------------------+    |
|        PCB0 에        |    |
|       상태 저장       |    |
+-----------------------+    |
            |              디스패치 지연
+-----------------------+    |
|       PCB1 에서       |    |
|       상태 복원       |    |
+-----------------------+    |
            |                |
+-----------------------+   ---
|        P1 실행        |
+-----------------------+ 
            |
```

컨텍스트 스위치가 얼마나 자주 발생하는가? `vmstat` 의 cs 값 확인한다.

```shell
dwkim@DESKTOP-A4LF2TT:~$ vmstat 1 3
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 1  0      0 6108328  15088 262392    0    0   247  1113   82  155  1  1 98  0  0
 0  0      0 6107580  15096 262384    0    0     0 18444   80  314  0  0 100  0  0
 0  0      0 6107808  15096 262392    0    0     0 20480  119  349  0  0 100  0  0
```
<br>

## 스케줄링 기준 _ Scheduling Criteria

다음은 CPU 스케줄링 알고리즘을 비교하기 위한 여러 기준이다.

- CPU 이용률 (utilization)
- 처리량 (throughput) : 단위 시간당 완료된 프로세스의 개수
- **총처리 시간(turnaround time)** : 프로세스의 제출 시간과 완료 시간의 간격 
- **대기 시간 (waiting time)** : 레디 큐에서의 대기 하면서 보낸 시간의 합
- 응답 시간 (response time) : 대화식 시스템이나 주로 UI에서 사용, 응답이 나올 때 까지의 시간

CPU 이용률 및 처리량을 최대화, 나머지를 최소화하는것이 바람직하다. 최적화를 위해, 응답 시간에 대해서는 편차(variance)를 최소화하는게 중요하다고 제시되고 있다고 한다.

<br>

## 스케줄링 알고리즘 _ Scheduling Algorithms

여러 CPU 스케줄링 알고리즘들에 대해 알아본다.

### 선입 선처리 스케줄링 FCFS _ First-Come, First-Served

가장 간단한 알고리즘으로 이름 그대로 먼저 요청한 프로세스한테 먼저 배정된다. FIFO Queue로 사용하기가 편리하다. 허나 평균대기 시간은 굉장히 길 수 있다. 

참여한 각 프로세스의 시작, 종료 시각을 포함하여 스케줄 기법을 도시하는 막대형 차트인 **Gantt 차트**로 다음 프로세스들을 살펴보자.

```
프로세스    버스트 시간
-----------------------
p1          24
p2          3
p3          3
-----------------------

Gantt 차트
+------------------------+---+---+
|                      p1| p2| p3|
+------------------------+---+---+
0                       24  27  30 (ms)
```
Gantt 차트로 대기 시간(waiting time)을 계산하면 total 0+24+27=51 평균 대기 시간은 17ms 이다.

이번엔 p2, p3, p1 순서로 도착하였다고 하면,

```
Gantt 차트
+---+---+------------------------+
| p2| p3|                      p1|
+---+---+------------------------+
0   3   6                       30
```
total 6+0+3=9 평균 대기 시간은 3ms 이다. 프로세스의 CPU 버스트 시간에 따라 차이가 많이 난다.

FCFS는 비선점형이고, 다른 프로세스들이 하나의 긴 프로세스를 CPU가 처리하는동안 기다리는 걸 convoy effect (호위 효과, 호송 효과, 똥차 효과; 오지게 길막한다고 똥차효과란다) 라 하며, 이때문에 FCFS로는 좋은 효율을 얻을 수 없다. 특히 하나의 CPU바운드 프로세스와 많은 io프로세스를 가정하면, waiting time 측면에서 엄청 늘어날 수밖에 없게 된다.


- waiting time 이 아닌 총처리 시간으로도 (turnaround time) 계산해보자
   - 처음의 차트
      - 전체 24+27+30=81 평균 27ms
   - 순서가 바뀌었을 때
      - 전체 3+6+30=39 평균 13ms


### 최단 작업 우선 스케줄링 SJF _ Shortest Job First 

CPU 버스트의 길이에 의해 스케줄링이 된다. 프로세스의 전체 길이가 아니라 다음 CPU 버스트의 길이에 의해 스케줄링 되기에 **최단 다음 CPU 버스트(shortest-next-CPU-burst)** 알고리즘이라고 하기도 한다. 가장 작은 다음 CPU 버스트를 가진 프로세스에 할당한다.

각 프로세스의 다음 CPU 버스트를 가지고 계산한다고 가정, CPU가 available할 때 next CPU버스트가 가장 작은것을 배정한다. 같다면 FCFS 적용

```
프로세스    버스트 시간
-----------------------
p1          6
p2          8
p3          7
p4          3
-----------------------

Gantt 차트
+---+------+-------+--------+
| p4|    p1|     p3|      p2|
+---+------+-------+--------+
0   3      9      16       24 (ms)
```
짧은걸 먼저 실행하고, 도착 순서와 무관하다. 대기 시간은 3+16+9+0=28, 평균 7 ms이다. 총처리 시간은 전체 3+9+16+24=52, 평균 13 ms이다.

이처럼 주어진 프로세스 집합에 대해 최소의 평균대기 시간을 가지기에 최적임을 증명할 수 있다. 하지만 다음 CPU버스트의 길이를 알 방법이 없어 CPU 스케줄링 수준에서는 구현할 수 없다고 한다. 그래서 근사한 방법으로 이전의 CPU 버스트들의 길이를 **지수(exponential) 평균**한 것으로 예측한다.

SJF 알고리즘은 선점형이거나 비선점형일 수 있는데, 선점형 SJF 알고리즘은 **최소 잔여 시간 우선 SRTF (Shortest Remaining Time First)** 라고도 한다. 

### RR : Round-Robin
시분할은 라운드 로빈과 관련이 있다. 정해진 시간을 공평히 쪼개서 쓰는 방법이다.

### Priority-based
우선순위 스케줄링

### MLQ : Multi-Level Queue
스케줄링 방법을 여러개 섞어서 사용

### MLFQ : Multi-Level Feedback Queue
여러 개 섞는 걸로 모자라 피드백까지 받아서 반영한다.






