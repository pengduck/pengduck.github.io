---
title: 메인 메모리 (Main Memory)
author: 펭덕
date: 2023-02-05 11:35:00 +0900
categories: [CS지식, OS]
tags: [공룡책, OS, Operating System, 운영체제, 메모리, Memory]
math: true
mermaid: true
image:
   src: https://user-images.githubusercontent.com/82709090/216818374-6b66167c-87c6-4f4c-8273-fcaff915f47f.png
---

공룡책(10판) Chapter 9 요약

드디어 프로세스 파트를 빠져나왔다.! 어우 길어

## 배경 _ Background

메모리는 주소가 있는 바이트의 배열로 구성되어있다. CPU는 프로그램 카운터가 지시하는 대로 메모리로부터 다음 수행할 명령어를 가져와 실행한다. 

### 기본 하드웨어 _ Basic Hardware

메인 메모리 : CPU가 접근할 수 있는 유일한 범용 저장장치

기계 명령어들은 메모리 주소만 인수로 취하고 디스크의 주소를 인수로 취하지 않는다. 따라서 실행되는 모든 명령어와 데이터는 CPU가 접근할 수 있는 메인 메모리와 레지스터에 있어야 한다.
CPU코어에 내장된 레지스터들은 일반적으로 `CPU clock 1 cycle` 내에 접근이 가능하다. 메인 메모리에 접근을 하기 위해서는 `많은 CPU clock tick cycle`이 소요된다.

- stall : CPU에 필요한 데이터가 없어서 명령어를 수행하지 못하고 지연되는 현상
- Cache : CPU와 메인 메모리 사이에 빠른 속도의 메모리인 캐시를 구축, stall 해결안

하드웨어는 물리 메모리의 상대적 접근 속도의 차이를 고려, 추가로 올바른 동작을 보장해야하며, 이를 위해 사용자 프로그램으로부터 운영체제 영역을 보호, 더불어 사용자 프로그램 사이도 보호한다. 

> 각각의 프로세스가 독립된 메모리 공간을 가지도록 보장

방법으로는 두 가지 레지스터를 이용, 합법적 영역을 설정하여 접근하도록 한다. `base ~ base+limit`

- base register 기준 레지스터 : 가장 작은 합법적인 물리 메모리 주소의 값을 저장
- limit register 상한 레지스터 : 주어진 영역의 크기를 저장

이를 벗어날 경우 trap을 일으켜 interrupt 발생시키게 된다.


### 주소 할당 _ Address Binding

프로그램은 디스크에 이진 실행 파일 형태로 저장되어 있으며, 실행하려면 프로그램을 메모리로 가져와 프로세스 문맥 내에 배치해야 한다.

사용자 프로그램은 컴파일러-링커-로더 단계를 거쳐 실행된다.

```
(소스 프로그램)
     |                            -+-
  [컴파일러]                   컴파일 시간
     |                            _+_
(오브젝트 파일)
     |
  [링커] (+ 다른 오브젝트 파일)   -+-
     |                             |
(실행 파일)                     적재 시간           
     |                             |
  [로더]                          -+-
     |
(메모리의 프로그램) (+ 동적 링크 라이브러리)  실행 시간(런타임)
```

1. 원시 프로그램에서 주소는 숫자가 아닌 심볼 형태로 표현되는데, 
2. 컴파일러는 이 심볼 주소를 잽재치 가능 주소로 바인딩시키고 
3. 다음에 링커와 로더가 재배치 가능 주소를 절대 주소로 바인딩시킨다.

메모리 주소 공간에서 명령어와 데이터의 바인딩은 시점에 따라 구분된다.

- 컴파일 시간 바인딩: 메모리 내에 들어갈 위치를 컴파일 시간 내에 미리 알 수 있다면 절대 주소 코드를 생성한다. 위치가 변경되면 코드는 다시 컴파일되어야 한다.
- 적재 시간 바인딩: 일단 이진 코드를 재배치 가능 코드를 만들고, 바인딩은 프로그램이 메인 메모리로 실제로 적재되는 시간에 이루어진다. 
- 실행 시간 바인딩: 실행 중 메모리 내의 한 세그먼틑로부터 다른 세그먼트로 옮겨질 수 있다면 바인딩이 실행 시간동안 허용되었다고 말한다. 특별한 하드웨어의 지원이 필요하다.


### 논리 대 물리 주소 공간 logical vs physical address space

CPU가 생성하는 주소를 논리 주소, 메모리에 올라간 주소를 물리 주소라 한다. 컴파일, 적재 시에 주소를 바인딩하면 둘은 같으나, 실행시간 바인딩 기법에서는 둘이 다르다. 이 경우 논리 주소를 `가상 주소`라고 한다.

프로그램 실행 중에는 가상 주소를 물리 주소로 바꾸어주어야 하는데 이 변환 작업은 하드웨어 장치인 `메모리 관리 장치 (Memory Management Unit, MMU)`에 의해 실행된다. 여기서는 기준 레지스터를 재배치 레지스터라 부른다.사용자 프로그램은 실제 물리 주소에 접근하지 않는다. base 위치를 0으로 치환한 형태라 생각하면 될 듯 싶다.

### 동적 적재 _ Dynamic loading

지금까지는 프로세스가 실행되기 위해 프로세스 전체가 미리 메모리에 올라와 있어야 했으나, 메모리의 효율적 이용을 위해서는 `동적 적재`를 해야 한다. 

프로그램 루틴은 호출되기 전까지는 메모리에 올라오지 않고 필요할 때마다 올라올 수 있도록 재배치 가능한 상태로 대기한다. main 프로그램만 우선 메모리에 적재되어 실행됨. 재배치 가능 연결 적재기가 요청된 루틴을 메모리로 가져와 테이블에 기록한다.

### 동적 연결 및 공유 라이브러리 _ Dynamic Linking & Shared Libraries

- DLL (dynamically linked library): 사용자 프로그램이 실행될 때 사용자 프로그램에 연결되는 시스템 라이브러리이다. 

- 정적 연결: 라이브러리가 프로그램의 이진 프로그램 이미지에 끼어 들어간다.

- 동적 연결: 로딩이 실행될 때까지 미루어진다.
   - 실행 가능 이미지의 크기를 감소하고 메인 메모리의 낭비를 줄인다.
   - 라이브러리를 여러 프로세스 간에 공유할 수 있어 DLL 인스턴스가 하나만 있어도 된다. 

프로그램이 동적 라이브러리에 있는 루틴을 참조하면 DLL을 찾아 필요한 메모리에 적재한다. 다음, 동적 라이브러리의 함수를 참조하는 주소를 DLL이 저장된 메모리의 위치로 조정한다.

새로운 버전으로 교체될 수도 있기에, 이 경우 새로운 라이브러리를 이용하기 위해 새로 링크되어야 하므로 버전 정보가 프로그램, 라이브러리에 포함되어야 한다.

> 동적 연결 vs 동적 적재: 동적 적재와는 달리 동적 연결은 운영체제의 도움이 필요하다. 메모리의 프로세스들이 각자의 공간은 자기만 엑세스할 수 있도록 보호된다면 운영체제만이 기억 공간에 루틴이 있는지 검사해 줄 수 있다. 

<br>

## 연속 메모리 할당 _ Contiguous memory Allocation

메모리는 일반적으로 두개의 부분으로 나누어진다; 운영체제, 사용자 프로세스

일반적으로 여러 사용자 프로세스가 동시에 메모리에 상주하기를 원하며, 연속적인 메모리 할당에서 각 프로세스는 다음 프로세스가 적재된 영역과 인접한 하나의 메모리 영역에 적재된다.

### 메모리 보호 _ Memory Protection

여기서 고려해야할 것이 메모리 보호 문제이다. 프로세스가 자신이 소유하지 않은 메모리를 접근할 수 없게 강제해야 한다. 

1. 재배치 레지스터는 가장 작은 물리 주소의 값을 저장하고, 상한 레지스터는 가능한 최대 논리 주소 값을 저장한다.
2. 각각의 논리 주소는 상한 레지스터가 지정한 범위 안에 존재해야 한다.
3.MMU는 동적으로 논리 주소에 재배치 레지스터의 값을 더함으로써 주소를 변환하는 역할을 수행한다.

CPU 스케줄러가 다음 수행 프로세스를 선택할 때, `디스패처`는 문맥 교환의 일환으로 재배치 레지스터와 상한 레지스터에 정확한 값을 적재한다. CPU에 의해 생성되는 모든 주소는 이 레지스터들의 값을 참조해 확인 작업을 거치므로 운영체제와 사용자 프로그램을 현재 수행 중 사용자 프로그램의 접근으로부터 보호할 수 있다.

> ...뭔가 포켓몬 글리치가 떠오르는 부분이군

### 메모리 할당 _ Memory Allocation

메모리를 할당하는 가장 간단한 방법 중 하나는 가변 크기 파티션에 할당하는 것. 각 파티션에는 하나의 프로세스만 적재될 수 있다. 프로세스의 할당 해제가 반복되면 다양한 크기의 hole이 발생한다. 

- 동적 메모리 할당 문제 : 저장공간에 동적으로 메모리를 할당할 때 여러 hole들 중에 n 바이트 블록을 어떻게 넣을 것이냐에 대한 문제로 다음과 같은 기법이 있다.
   - First-Fit (최초 적합): 검색은 집합의 시작부터, 가장 먼저 사용 가능한 가용 공간을 할당한다. 
   - Best-Fit (최적 적합): 사용 가능한 공간 중 가장 작은 것을 택한다. 리스트가 크기 순이 아니라면 전 리스트를 검색한다.
   - Worst-Fit (최악 적합): 사용 가능한 가장 큰 공간에 할당한다. 남는 가용 공간을 다른 프로세스가 활용할 수도 있다.


### 단편화 _ Fragmentation

- 외부 단편화(external fragmentation): 최초 적합, 최적 적합 모두 `외부 단편화(external fragmentation)`의 문제를 겪는다. 자투리 공간을 최소로 맞추려다 보니 그 조각들이 할당받을 곳이 없는 것.

- 50% 규칙: 최초 적합의 경우 통계적으로 분석하면 N개의 블록 할당 시 0.5N개의 블록이 단편화 때문에 손실될 수 있다고 한다. 즉, 메모리의 1/3이 못쓰게 된다는 것.

- 내부 단편화(internal fragmentation): 메모리를 먼저 작은 공간으로 분할하고 프로세스가 요청하면 이 분할된 크기의 정수배로 해주는 것이 보통인데, 할당된 공간이 요구된 공간보다 약간 더 클 때 남는 부분이 내부 단편화이다.

- 해결 방안
   1. 압축: 메모리 모든 내용을 한군데로 몰고 모든 가용 공간을 다른 한군데로 모아서 큰 블록을 만든다. 재배치가 어셈블 또는 적재 시에 정적으로 행해진다면 압축은 불가하다. 재배치가 실행시간에 동적으로 이루어지는 경우에만 가능하다.
   2. 프로세스의 논리 주소 공간을 여러 개의 비연속적인 공간으로 나누어 필요한 크기의 공간이 가용해지는 경우 물리 메모리를 프로세스에 할당하는 방법이다. (페이징)


> 세그맨테이션 (Segmentation): 페이징은 프로세스를 물리적으로 일정한 크기로 나누었다면 세그맨테이션은 논리적으로 나누는 것. code, data, stack 영역으로 나누는 것도 세그맨테이션이라고 한다. 세그먼트 테이블을 가지고 각 테이블에 limit를 가진다.